<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Citrin's APCSP Console</title>
<style>
:root {
  --bg: #1e1e1e;
  --panel-bg: #252526;
  --border: #3c3c3c;
  --text-primary: #d4d4d4;
  --text-muted: #808080;
  --run-btn-bg: #5f9040;
  --run-btn-text: #ffffff;
  --stop-btn-bg: #a33b3b;
  --console-bg: #1e1e1e;
  --console-log: #d4d4d4;
  --console-err: #ff8c8c;
  --console-sys: #92a4c1;
  --editor-bg: #1e1e1e;
  --editor-text: #d4d4d4;
  --editor-caret: #aeafad;
}
* { box-sizing: border-box; }
body {
  margin: 0;
  background: var(--bg);
  color: var(--text-primary);
  font: 16px/1.45 'JetBrains Mono', 'Fira Code', ui-monospace, Menlo, Consolas, monospace;
  display: flex;
  flex-direction: column;
  height: 100vh;
}
header {
  padding: 10px 15px;
  border-bottom: 1px solid var(--border);
  background: var(--panel-bg);
  color: var(--text-primary);
  font-size: 16px;
  font-weight: bold;
  flex-shrink: 0;
}
header span {
  font-weight: normal;
  color: var(--text-muted);
}
main {
  flex-grow: 1;
  display: grid;
  grid-template-columns: 1.1fr 0.9fr;
  gap: 10px;
  padding: 10px;
  min-height: 0;
}
.card {
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  min-height: 0;
}
.card h2 {
  font-size: 14px;
  margin: 0;
  padding: 8px 12px;
  color: var(--text-primary);
  border-bottom: 1px solid var(--border);
  background: #333333;
  flex-shrink: 0;
}
.toolbar {
  display: flex;
  gap: 8px;
  padding: 8px 12px;
  border-bottom: 1px solid var(--border);
  align-items: center;
  flex-wrap: wrap;
  flex-shrink: 0;
}
button, select {
  background: #3c3f41;
  color: var(--text-primary);
  border: 1px solid var(--border);
  padding: 6px 10px;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 500;
  font-size: 13px;
}
button.primary {
  background: var(--run-btn-bg);
  color: var(--run-btn-text);
  border-color: var(--run-btn-bg);
}
button.danger {
  background: var(--stop-btn-bg);
  color: var(--run-btn-text);
  border-color: var(--stop-btn-bg);
}
.editor-wrapper {
  flex-grow: 1;
  display: flex;
  overflow: hidden;
}
.line-numbers {
  background: #1a1a1a;
  color: #858585;
  padding: 12px 8px;
  text-align: right;
  user-select: none;
  font: 14px/1.45 'JetBrains Mono', 'Fira Code', ui-monospace, Menlo, Consolas, monospace;
  border-right: 1px solid var(--border);
  overflow: hidden;
  min-width: 40px;
  white-space: pre;
}
textarea {
  flex-grow: 1;
  width: 100%;
  height: 100%; 
  resize: none; 
  background: var(--editor-bg);
  color: var(--editor-text);
  border: 0;
  outline: none;
  padding: 12px 14px;
  font: 14px/1.45 'JetBrains Mono', 'Fira Code', ui-monospace, Menlo, Consolas, monospace;
  caret-color: var(--editor-caret);
  overflow: auto;
}
.console {
  flex-grow: 1;
  overflow: auto;
  padding: 12px;
  font: 14px/1.5 'JetBrains Mono', 'Fira Code', ui-monospace, Menlo, Consolas, monospace;
  background: var(--console-bg);
  white-space: pre-wrap;
}
.log { color: var(--console-log); }
.err { color: var(--console-err); }
.sys { color: var(--console-sys); }
.prompt-wrap { display: none; gap: 8px; padding: 10px; border-top: 1px solid var(--border); background: var(--panel-bg); align-items: center; flex-shrink: 0; }
.prompt-wrap input { flex: 1; background: #3c3f41; color: var(--text-primary); border: 1px solid var(--border); border-radius: 4px; padding: 8px 10px; }
.prompt-wrap.show { display: flex; }
.status { padding: 8px 12px; font-size: 12px; color: var(--text-muted); border-top: 1px solid var(--border); background: var(--panel-bg); flex-shrink: 0; }
footer {
  color: var(--text-muted);
  text-align: center;
  font-size: 12px;
  padding: 10px;
  background: var(--panel-bg);
  border-top: 1px solid var(--border);
  flex-shrink: 0;
}
</style>
</head>

<body>
<header>
  Citrin's APCSP Console <span>(Version 2.0 - With Line Numbers)</span>
</header>

<main>
  <section class="card">
     <h2>Program</h2>
    <div class="toolbar">
      <button class="primary" id="runBtn">‚ñ∂ Run</button>
      <button id="stopBtn" class="danger">‚ñ† Stop</button>
      <select id="samples"></select>
      <span style="margin-left:auto; color: var(--text-muted); font-size: 13px;">Ctrl/‚åò + Enter</span>
    </div>
    <div class="editor-wrapper">
      <div class="line-numbers" id="lineNumbers"></div>
      <textarea id="editor"></textarea>
    </div>
  </section>

  <section class="card">
    <h2>Console</h2>
    <div class="console" id="console"></div>
    <div class="prompt-wrap" id="promptWrap">
      <input id="promptInput" placeholder="Enter input‚Ä¶" />
      <button id="promptOk">OK</button>
      <button id="promptCancel">Cancel</button>
    </div>
    <div class="status" id="status">Idle</div>
  </section>
</main>

<footer>AP CSP Emulator</footer>

<script>
window.addEventListener("DOMContentLoaded", () => {
  const $ = s => document.querySelector(s);

  const logEl = $("#console"), statusEl = $("#status"), editor = $("#editor");
  const lineNumbers = $("#lineNumbers");
  const promptWrap = $("#promptWrap"), promptInput = $("#promptInput");
  const promptOk = $("#promptOk"), promptCancel = $("#promptCancel");
  let halted = false, inputResolve=null, inputReject=null;

  function updateLineNumbers() {
    const lines = editor.value.split('\n').length;
    lineNumbers.innerHTML = Array.from({length: lines}, (_, i) => i + 1).join('\n');
  }

  editor.addEventListener('input', updateLineNumbers);
  editor.addEventListener('scroll', () => {
    lineNumbers.scrollTop = editor.scrollTop;
  });

  const out=(m,c="log")=>{const d=document.createElement("div");d.className="line "+c;d.textContent=String(m);logEl.appendChild(d);logEl.scrollTop=logEl.scrollHeight;}
  const log=m=>out(m,"log"), err=m=>out(m,"err"), sys=m=>out(m,"sys");
  const setStatus = s => statusEl.textContent = s;

  function showPrompt(label){ 
    promptInput.value=""; 
    promptInput.placeholder=label||"Input"; 
    promptWrap.classList.add("show"); 
    promptInput.focus(); 
    return new Promise((res,rej)=>{inputResolve=res;inputReject=rej;}); 
  }
  function hidePrompt(){ promptWrap.classList.remove("show"); }
  promptOk.onclick=()=>{ if(inputResolve){ inputResolve(promptInput.value); hidePrompt(); inputResolve=null; inputReject=null; } };
  promptCancel.onclick=()=>{ if(inputReject){ inputReject(new Error("Input cancelled")); hidePrompt(); inputResolve=null; inputReject=null; } };
  promptInput.addEventListener("keydown", e=>{ if(e.key==="Enter")promptOk.click(); if(e.key==="Escape")promptCancel.click(); });

  function preprocess(src){
    return src.split(/\r?\n/).map((raw,idx)=>{
      const s = raw
        .replace(/#.*$/,"").replace(/\/\/.*$/,"") 
        .replace(/\t/g,"    ").trim(); 
      return { idx, raw, s };
    });
  }

  function parseProcedures(lines){
    const procs = {};
    let i = 0;
    while (i < lines.length) {
      const t = lines[i].s;
      if(/^PROCEDURE\b/i.test(t)){
        const m = t.match(/^PROCEDURE\s+([A-Za-z_]\w*)\s*\(([^)]*)\)/i);
        if(!m) throw `Bad PROCEDURE syntax at line ${lines[i].idx+1}`;
        const name = m[1];
        const params = m[2].trim() ? m[2].split(",").map(s=>s.trim()) : [];
        
        i++;
        if (i >= lines.length || lines[i].s !== "{") {
          throw `PROCEDURE ${name} at line ${lines[i-1].idx+1} must be followed by {`;
        }
        
        const bodyStart = i + 1;
        let depth = 1;
        i++;
        while (i < lines.length && depth > 0) {
          if (lines[i].s === "{") depth++;
          else if (lines[i].s === "}") depth--;
          i++;
        }
        
        if (depth !== 0) throw `Unclosed PROCEDURE ${name}`;
        
        const bodyEnd = i - 1;
        procs[name] = { name, params, start: bodyStart, end: bodyEnd };
      } else {
        i++;
      }
    }
    return procs;
  }

  let LINES=[], PROCS=null, ENV=null;

  function makeEval(env, procs){
    const safe=/^[\w\s+\-*/%().,<>!="""'\[\]‚â§‚â•‚â†?:&|]+$/u;
    
    function rewrite(expr){
      let result = expr
        .replace(/[""]/g,'"')
        .replace(/‚â§/g,"<=").replace(/‚â•/g,">=").replace(/‚â†/g,"!=")
        .replace(/\bAND\b/gi,"&&").replace(/\bOR\b/gi,"||").replace(/\bNOT\b/gi,"!")
        .replace(/\bMOD\b/gi,"%")
        .replace(/([A-Za-z_]\w*)\s*\[\s*([^\]]+)\s*\]/g, "IDX($1,($2))");
      
      result = result.replace(/([^<>!=])=([^=])/g, '$1==$2');
      
      // Add await before procedure calls
      for (const procName in procs) {
        const regex = new RegExp(`\\b${procName}\\s*\\(`, 'g');
        result = result.replace(regex, `await ${procName}(`);
      }
      
      return result;
    }

    async function callProc(name, args, callerEnv){
      const def = procs[name];
      if(!def) throw `Unknown procedure '${name}'`;
      const local = Object.create(callerEnv);
      for(let i=0; i<def.params.length; i++) {
        local[def.params[i]] = i < args.length ? args[i] : undefined;
      }
      const result = await execRange(def.start, def.end, local, true); 
      return result !== undefined && result !== null ? result : null;
    }

    return async function evalExpr(expr){
      const e = rewrite(expr);
      if(!safe.test(e)) throw `Expression contains unsupported characters: ${e}`;

      const scope = {
          Math,
          RANDOM: (a, b) => Math.floor(Math.random() * (b - a + 1)) + a,
          INPUT: async () => {
            const val = await showPrompt("Input");
            return isNaN(val) ? val : Number(val);
          },
          APPEND: (L,v)=>{ 
            if(!Array.isArray(L)) throw "APPEND: first argument must be a list"; 
            L.push(v); 
          },
          INSERT: (L,i,v)=>{ 
            if(!Array.isArray(L)) throw "INSERT: first argument must be a list";
            if (i < 1 || i > L.length + 1) throw `INSERT: invalid index ${i}`;
            L.splice(i-1,0,v); 
          },
          REMOVE: (L,i)=>{ 
            if(!Array.isArray(L)) throw "REMOVE: first argument must be a list";
            if (i < 1 || i > L.length) throw `REMOVE: invalid index ${i}`;
            L.splice(i-1,1); 
          },
          LENGTH: L=>{ 
            if(L == null) throw "LENGTH: argument is null"; 
            if(!Array.isArray(L)) throw "LENGTH: argument must be a list"; 
            return L.length; 
          },
          IDX: (L,i)=>{
            if(L == null) throw "List index: list is null";
            if(!Array.isArray(L)) throw "List index: not a list";
            if (i < 1 || i > L.length) throw `List index out of bounds: ${i} (length is ${L.length})`;
            return L[i-1];
          }
      };
      
      let currentEnv = env;
      while (currentEnv) {
        for (const key of Object.getOwnPropertyNames(currentEnv)) {
            if (!scope.hasOwnProperty(key)) {
                scope[key] = currentEnv[key];
            }
        }
        const proto = Object.getPrototypeOf(currentEnv);
        if (!proto || proto === Object.prototype) break;
        currentEnv = proto;
      }
      
      for (const name in procs) {
          if (!scope.hasOwnProperty(name)) {
            scope[name] = async (...args) => {
              const result = await callProc(name, args, env);
              return result;
            };
          }
      }
      
      const scopeKeys = Object.keys(scope);
      const scopeValues = Object.values(scope);

      // Create async function that uses await properly
      const asyncFn = new Function(...scopeKeys, `
        return (async function() {
          return (${e});
        })();
      `);
      return await asyncFn(...scopeValues);
    };
  }

  async function execRange(start, end, env, insideProc=false){
    const evalExpr = makeEval(env, PROCS);
    let i = start;

    while(i < end){ 
      if(halted) return null;
      const {s, idx} = LINES[i];
      
      if(!s || s === "{" || s === "}") {
        i++;
        continue;
      }

      if(!insideProc && /^PROCEDURE\b/i.test(s)){
        const m = s.match(/^PROCEDURE\s+([A-Za-z_]\w*)/i);
        const name = m[1];
        const def = PROCS[name];
        i = def.end + 1;
        continue;
      }

      if(/^RETURN\b/i.test(s)){
        if(!insideProc) throw `RETURN outside procedure at line ${idx+1}`;
        const m = s.match(/^RETURN\s*\((.*)\)/i);
        if (!m) return null;
        const returnVal = m[1].trim() ? await evalExpr(m[1]) : null;
        return returnVal;
      }
      
      if(/^DISPLAY\s*\(/i.test(s)){
        const m = s.match(/^DISPLAY\s*\((.*)\)/i);
        const val = await evalExpr(m[1]);
        log(val);
        i++;
        continue;
      }
      
      if(/^[A-Za-z_]\w*\s*(‚Üê|<-)\s*(.*)$/.test(s)){
        const m = s.match(/^([A-Za-z_]\w*)\s*(?:‚Üê|<-)\s*(.*)$/);
        const varName = m[1];
        const expr = m[2];
        const val = await evalExpr(expr);
        
        let targetEnv = env;
        let found = false;
        while(targetEnv) {
            if (Object.prototype.hasOwnProperty.call(targetEnv, varName)) {
                targetEnv[varName] = val;
                found = true;
                break;
            }
            const proto = Object.getPrototypeOf(targetEnv);
            if (!proto || proto === Object.prototype) break;
            targetEnv = proto;
        }
        
        if (!found) {
            env[varName] = val;
        }
        
        i++;
        continue;
      }

      if(/^[A-Za-z_]\w*\s*\[\s*.*\s*\]\s*(‚Üê|<-)\s*(.*)$/.test(s)){
        const m = s.match(/^([A-Za-z_]\w*)\s*\[\s*(.*?)\s*\]\s*(?:‚Üê|<-)\s*(.*)$/);
        const listName = m[1];
        const indexExpr = m[2];
        const valueExpr = m[3];
        
        const list = await evalExpr(listName);
        const index = await evalExpr(indexExpr);
        const value = await evalExpr(valueExpr);
        
        if (!Array.isArray(list)) throw `${listName} is not a list at line ${idx+1}`;
        if (index < 1 || index > list.length) throw `Index ${index} out of bounds at line ${idx+1}`;
        
        list[index - 1] = value;
        i++;
        continue;
      }
      
      if(/^IF\s*\(/i.test(s)){
        const m = s.match(/^IF\s*\((.*)\)/i);
        const cond = await evalExpr(m[1]);
        
        i++;
        if (i >= end || LINES[i].s !== "{") {
          throw `IF at line ${idx+1} must be followed by {`;
        }
        
        const blockStart = i + 1;
        let depth = 1;
        i++;
        while (i < end && depth > 0) {
          if (LINES[i].s === "{") depth++;
          else if (LINES[i].s === "}") depth--;
          i++;
        }
        const blockEnd = i - 1;
        
        if (cond) {
          const result = await execRange(blockStart, blockEnd, env, insideProc);
          if (insideProc && result !== undefined && result !== null) {
            return result;
          }
          
          if (i < end && /^ELSE\b/i.test(LINES[i].s)) {
            i++;
            if (i < end && LINES[i].s === "{") {
              depth = 1;
              i++;
              while (i < end && depth > 0) {
                if (LINES[i].s === "{") depth++;
                else if (LINES[i].s === "}") depth--;
                i++;
              }
            }
          }
        } else {
          if (i < end && /^ELSE\b/i.test(LINES[i].s)) {
            i++;
            if (i >= end || LINES[i].s !== "{") {
              throw `ELSE at line ${LINES[i-1].idx+1} must be followed by {`;
            }
            
            const elseStart = i + 1;
            depth = 1;
            i++;
            while (i < end && depth > 0) {
              if (LINES[i].s === "{") depth++;
              else if (LINES[i].s === "}") depth--;
              i++;
            }
            const elseEnd = i - 1;
            
            const result = await execRange(elseStart, elseEnd, env, insideProc);
            if (insideProc && result !== undefined && result !== null) {
              return result;
            }
          }
        }
        continue;
      }
      
      if(/^REPEAT\s+(\d+|\(.*?\)|\S+)\s+TIMES/i.test(s)){
        const m = s.match(/^REPEAT\s+(.*?)\s+TIMES/i);
        const countExpr = m[1];
        const n = await evalExpr(countExpr);
        
        i++;
        if (i >= end || LINES[i].s !== "{") {
          throw `REPEAT TIMES at line ${idx+1} must be followed by {`;
        }
        
        const blockStart = i + 1;
        let depth = 1;
        i++;
        while (i < end && depth > 0) {
          if (LINES[i].s === "{") depth++;
          else if (LINES[i].s === "}") depth--;
          i++;
        }
        const blockEnd = i - 1;
        
        for (let rep = 0; rep < n; rep++) {
          if (halted) return null;
          const result = await execRange(blockStart, blockEnd, env, insideProc);
          if (result !== undefined && result !== null && insideProc) return result;
        }
        continue;
      }
      
      if(/^REPEAT\s+UNTIL\s*\(/i.test(s)){
        const m = s.match(/^REPEAT\s+UNTIL\s*\((.*)\)/i);
        const condExpr = m[1];
        
        i++;
        if (i >= end || LINES[i].s !== "{") {
          throw `REPEAT UNTIL at line ${idx+1} must be followed by {`;
        }
        
        const blockStart = i + 1;
        let depth = 1;
        i++;
        while (i < end && depth > 0) {
          if (LINES[i].s === "{") depth++;
          else if (LINES[i].s === "}") depth--;
          i++;
        }
        const blockEnd = i - 1;
        
        while (true) {
          if (halted) return null;
          const result = await execRange(blockStart, blockEnd, env, insideProc);
          if (result !== undefined && result !== null && insideProc) return result;
          
          const cond = await evalExpr(condExpr);
          if (cond) break;
        }
        continue;
      }
      
      if(/^FOR\s+EACH\s+/i.test(s)){
        const m = s.match(/^FOR\s+EACH\s+(\w+)\s+IN\s+(.+)/i);
        if (!m) throw `Invalid FOR EACH syntax at line ${idx+1}`;
        const itemVar = m[1];
        const listExpr = m[2];
        
        const list = await evalExpr(listExpr);
        if (!Array.isArray(list)) throw `FOR EACH at line ${idx+1}: ${listExpr} is not a list`;
        
        i++;
        if (i >= end || LINES[i].s !== "{") {
          throw `FOR EACH at line ${idx+1} must be followed by {`;
        }
        
        const blockStart = i + 1;
        let depth = 1;
        i++;
        while (i < end && depth > 0) {
          if (LINES[i].s === "{") depth++;
          else if (LINES[i].s === "}") depth--;
          i++;
        }
        const blockEnd = i - 1;
        
        for (const item of list) {
          if (halted) return null;
          env[itemVar] = item;
          const result = await execRange(blockStart, blockEnd, env, insideProc);
          if (result !== undefined && result !== null && insideProc) return result;
        }
        
        delete env[itemVar];
        continue;
      }

      if(/^(APPEND|INSERT|REMOVE)\s*\(/i.test(s)) {
        await evalExpr(s); 
        i++;
        continue;
      }
      
      if(/^[A-Za-z_]\w*\s*\(/i.test(s)){
        const m = s.match(/^([A-Za-z_]\w*)/);
        if(m && PROCS[m[1]]){
          await evalExpr(s);
          i++;
          continue;
        }
      }

      throw `Unknown statement at line ${idx+1}: "${s}"`;
    }
    return null;
  }

  async function run(src){
    halted=false; logEl.innerHTML=""; setStatus("Parsing‚Ä¶");
    try{
      LINES = preprocess(src);
      PROCS = parseProcedures(LINES);
      ENV = Object.create(null);
    }catch(e){ err("Parse Error: " + e); setStatus("Parse Error"); return; }

    setStatus("Running‚Ä¶");
    try{
      await execRange(0, LINES.length, ENV, false);
      setStatus("Finished");
    }catch(e){ 
      err("Runtime Error: " + e); 
      setStatus("Error"); 
    }
  }

  $("#runBtn").onclick = ()=> run(editor.value);
  $("#stopBtn").onclick = ()=> { halted=true; if(inputReject){inputReject(new Error("Stopped"));hidePrompt();} setStatus("Stopped"); };
  document.addEventListener("keydown", e=>{
    if((e.ctrlKey||e.metaKey) && e.key==="Enter"){ e.preventDefault(); $("#runBtn").click(); }
  });

  const samples = {
"Hello World":
`DISPLAY("Hello, World!")`,

"Variables & Assignment":
`a ‚Üê 10
b ‚Üê "Hello"
DISPLAY(b)
a ‚Üê a * 2
DISPLAY(a)`,

"Arithmetic & MOD":
`x ‚Üê 17 / 5
DISPLAY(x)
y ‚Üê 17 MOD 5
DISPLAY(y)
DISPLAY(10 + 3 * 2)`,

"IF Statement":
`age ‚Üê 20
IF (age >= 18)
{
  DISPLAY("Adult")
}`,

"IF-ELSE":
`score ‚Üê 85
IF (score >= 90)
{
  DISPLAY("A grade")
}
ELSE
{
  DISPLAY("Not an A")
}`,

"Relational Operators":
`a ‚Üê 5
b ‚Üê 10
IF (a < b)
{
  DISPLAY("a is less than b")
}
IF (a ‚â• 5)
{
  DISPLAY("a is at least 5")
}`,

"Boolean AND/OR":
`x ‚Üê 15
IF (x > 10 AND x < 20)
{
  DISPLAY("x is between 10 and 20")
}
IF (x < 5 OR x > 10)
{
  DISPLAY("x is outside 5-10 range")
}`,

"NOT Operator":
`ready ‚Üê true
IF (NOT ready)
{
  DISPLAY("Not ready")
}
ELSE
{
  DISPLAY("Ready to go!")
}`,

"REPEAT n TIMES":
`REPEAT 5 TIMES
{
  DISPLAY("Hello!")
}`,

"REPEAT UNTIL":
`count ‚Üê 0
REPEAT UNTIL (count >= 3)
{
  DISPLAY(count)
  count ‚Üê count + 1
}`,

"Lists - Creation & Access":
`myList ‚Üê [10, 20, 30, 40]
DISPLAY(myList[1])
DISPLAY(myList[3])
DISPLAY(LENGTH(myList))`,

"Lists - Modification":
`nums ‚Üê [5, 10, 15]
nums[2] ‚Üê 99
DISPLAY(nums[2])
APPEND(nums, 20)
DISPLAY(LENGTH(nums))`,

"INSERT & REMOVE":
`items ‚Üê [1, 2, 3]
INSERT(items, 2, 99)
DISPLAY(items[2])
REMOVE(items, 1)
DISPLAY(items[1])`,

"FOR EACH Loop":
`numbers ‚Üê [10, 20, 30, 40]
FOR EACH num IN numbers
{
  DISPLAY(num)
}`,

"Procedure - No Return":
`PROCEDURE greet(name)
{
  DISPLAY("Hello, " + name + "!")
}

greet("Alice")
greet("Bob")`,

"Procedure - With Return":
`PROCEDURE square(n)
{
  RETURN (n * n)
}

result ‚Üê square(7)
DISPLAY(result)
DISPLAY(square(10))`,

"Nested Procedures":
`PROCEDURE double(x)
{
  RETURN (x * 2)
}

PROCEDURE quadruple(x)
{
  RETURN (double(double(x)))
}

DISPLAY(quadruple(5))`,

"Procedure Call in DISPLAY":
`PROCEDURE areaCircle(r)
{
  pi ‚Üê 3.14159
  RETURN (pi * (r*r))
}

PROCEDURE areaFinder(r)
{
  DISPLAY("your area is: " + areaCircle(r))
}

areaFinder(5)`,

"INPUT Example":
`DISPLAY("What is your name?")
name ‚Üê INPUT()
DISPLAY("Hello, " + name)
DISPLAY("Enter a number:")
num ‚Üê INPUT()
DISPLAY("Double: " + (num * 2))`,

"RANDOM Function":
`DISPLAY("Rolling dice...")
roll ‚Üê RANDOM(1, 6)
DISPLAY("You rolled: " + roll)`,

"MOD Operator":
`remainder ‚Üê 10 MOD 3
DISPLAY("10 MOD 3 = " + remainder)

num ‚Üê 7
IF (num MOD 2 = 0)
{
  DISPLAY(num + " is even")
}
ELSE
{
  DISPLAY(num + " is odd")
}`,

"RANDOM + MOD (Even/Odd Game)":
`randomNum ‚Üê RANDOM(1, 100)
DISPLAY("Random number: " + randomNum)

IF (randomNum MOD 2 = 0)
{
  DISPLAY("It's EVEN!")
}
ELSE
{
  DISPLAY("It's ODD!")
}`,

"Complex Example":
`scores ‚Üê [85, 92, 78, 95, 88]
total ‚Üê 0

FOR EACH score IN scores
{
  total ‚Üê total + score
}

average ‚Üê total / LENGTH(scores)
DISPLAY("Average score: " + average)

IF (average >= 90)
{
  DISPLAY("Excellent!")
}
ELSE
{
  DISPLAY("Good job!")
}`
  };

  const sel = $("#samples");
  sel.innerHTML = '<option value="">üìã Load Sample...</option>' +
    Object.keys(samples).map(k=>`<option>${k}</option>`).join('');
  sel.onchange = e=>{ const k=e.target.value; if(samples[k]) { editor.value=samples[k]; updateLineNumbers(); } e.target.value=""; };

  editor.value = `DISPLAY("Welcome to AP CSP Console!")
DISPLAY("Select a sample or write your code.")`;
  updateLineNumbers();

  setStatus("Ready"); 
  sys("‚úì Emulator ready. Press Run to execute.");
});
</script>
</body>
</html>
