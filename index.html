<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TechBoston CSP Console â€” STRICT AP CSP</title>
<style>
:root { --bg:#fff; --panel:#0b0f14; --accent:#60a5fa; --muted:#9aa4b2; --border:#1f2937; }
*{box-sizing:border-box}
body{margin:0;background:#fff;color:#e5e7eb;font:16px/1.45 system-ui,-apple-system,Segoe UI,Inter,Roboto,sans-serif}
header{padding:18px 20px;border-bottom:1px solid var(--border);background:#fff;position:sticky;top:0;z-index:1}
h1{margin:0 0 6px;font-size:20px}
.sub{color:var(--muted);font-size:13px}
main{display:grid;grid-template-columns:1.1fr .9fr;gap:16px;padding:16px}
.card{background:#0a0a0a;border:1px solid var(--border);border-radius:14px;overflow:hidden;box-shadow:0 10px 25px rgba(0,0,0,.4)}
.card h2{font-size:14px;margin:0;padding:10px 12px;color:#cbd5e1;border-bottom:1px solid var(--border);background:#0b0b0b}
.toolbar{display:flex;gap:8px;padding:10px;border-bottom:1px solid var(--border);align-items:center;flex-wrap:wrap}
button,select{background:#141a26;color:#e5e7eb;border:1px solid var(--border);padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600}
button.primary{background:var(--accent);color:#05122a;border-color:#3b82f6}
button.danger{background:#1a1620;color:#fecaca;border-color:#7f1d1d}
textarea{width:100%;height:520px;resize:vertical;background:#0c1320;color:#e5e7eb;border:0;outline:none;padding:12px 14px;font:14px/1.45 ui-monospace,Menlo,Consolas,monospace;caret-color:var(--accent)}
.console{height:560px;overflow:auto;padding:12px;font:14px/1.5 ui-monospace,Menlo,Consolas,monospace;background:#05080f}
.line{white-space:pre-wrap}
.log{color:#d1fae5}.err{color:#fecaca}.sys{color:#93c5fd}
.status{padding:8px 12px;font-size:12px;color:var(--muted);border-top:1px solid var(--border);background:#0e1522}
.prompt-wrap{display:none;gap:8px;padding:10px;border-top:1px solid var(--border);background:#0d1420}
.prompt-wrap input{flex:1;background:#0b1220;color:#e5e7eb;border:1px solid var(--border);border-radius:10px;padding:10px 12px}
.prompt-wrap.show{display:flex}
footer{color:var(--muted);text-align:center;font-size:12px;padding:10px}
</style>
</head>

<body>
<header>
Â  <h1>TechBoston CSP Console <span style="opacity:.7">(AP CSP Relaxed)</span></h1>
Â  <div class="sub">
Â  Â  SET, DISPLAY, INPUT, IF/ELSE/END IF, REPEAT n TIMES/END REPEAT, REPEAT UNTIL/END REPEAT, PROCEDURE/RETURN/END PROCEDURE.
Â  Â  Lists 1-based; APPEND/INSERT/REMOVE; LENGTH OF. **CALL is optional** for statements. **Braces `{}` allowed**.
Â  </div>
</header>

<main>
Â  <section class="card">
Â  Â  <h2>Program</h2>
Â  Â  <div class="toolbar">
Â  Â  Â  <button class="primary" id="runBtn">â–¶ Run</button>
Â  Â  Â  <button id="stopBtn" class="danger">â–  Stop</button>
Â  Â  Â  <select id="samples"></select>
Â  Â  Â  <span style="margin-left:auto"></span>
Â  Â  Â  <span class="sub">Ctrl/âŒ˜ + Enter</span>
Â  Â  </div>
Â  Â  <textarea id="editor"></textarea>
Â  </section>

Â  <section class="card">
Â  Â  <h2>Console</h2>
Â  Â  <div class="console" id="console"></div>
Â  Â  <div class="prompt-wrap" id="promptWrap">
Â  Â  Â  <input id="promptInput" placeholder="Enter inputâ€¦" />
Â  Â  Â  <button id="promptOk">OK</button>
Â  Â  Â  <button id="promptCancel">Cancel</button>
Â  Â  </div>
Â  Â  <div class="status" id="status">Idle</div>
Â  </section>
</main>

<footer>MIT Â· Single-file Â· Black BG for easy version check ğŸ–¤</footer>

<script>
window.addEventListener("DOMContentLoaded", () => {
Â  const $ = s => document.querySelector(s);

Â  // UI
Â  const logEl = $("#console"), statusEl = $("#status"), editor = $("#editor");
Â  const promptWrap = $("#promptWrap"), promptInput = $("#promptInput");
Â  const promptOk = $("#promptOk"), promptCancel = $("#promptCancel");
Â  let halted = false, inputResolve=null, inputReject=null;

Â  const out=(m,c="log")=>{const d=document.createElement("div");d.className="line "+c;d.textContent=String(m);logEl.appendChild(d);logEl.scrollTop=logEl.scrollHeight;}
Â  const log=m=>out(m,"log"), err=m=>out(m,"err"), sys=m=>out(m,"sys");
Â  const setStatus = s => statusEl.textContent = s;

Â  function showPrompt(label){ promptInput.value=""; promptInput.placeholder=label||"Input"; promptWrap.classList.add("show"); promptInput.focus(); return new Promise((res,rej)=>{inputResolve=res;inputReject=rej;}); }
Â  function hidePrompt(){ promptWrap.classList.remove("show"); }
Â  promptOk.onclick=()=>{ if(inputResolve){ inputResolve(promptInput.value); hidePrompt(); } };
Â  promptCancel.onclick=()=>{ if(inputReject){ inputReject("cancel"); hidePrompt(); } };
Â  promptInput.addEventListener("keydown", e=>{ if(e.key==="Enter")promptOk.click(); if(e.key==="Escape")promptCancel.click(); });

Â  // ---------- Preprocess ----------
Â  function preprocess(src){
Â  Â  return src.split(/\r?\n/).map((raw,idx)=>{
Â  Â  Â  const s = raw
Â  Â  Â  Â  .replace(/#.*$/,"").replace(/\/\/.*$/,"")
Â  Â  Â  Â  //.replace(/[{}]/g,"") // Removing this to let { } act as block delimiters
Â  Â  Â  Â  .replace(/\t/g," Â  Â ").trim();
Â  Â  Â  return { idx, raw, s };
Â  Â  });
Â  }

Â  // ---------- Block map ----------
Â  function buildBlocks(lines){
Â  Â  const blocks = { if:{}, repStartToEnd:{}, repEndToStart:{} };
Â  Â  const stack = [];
Â  Â  for (let i=0;i<lines.length;i++){
Â  Â  Â  const t = lines[i].s;
Â  Â  Â  if(!t) continue;

Â  Â  Â  if(/^IF\b/i.test(t)) { stack.push({type:"IF", i}); }
Â  Â  Â  else if(/^ELSE\b/i.test(t)) {
Â  Â  Â  Â  const top = stack.at(-1);
Â  Â  Â  Â  if(!top || top.type!=="IF") throw `ELSE without IF at line ${i+1}`;
Â  Â  Â  Â  blocks.if[top.i] = blocks.if[top.i] || {};
Â  Â  Â  Â  blocks.if[top.i].else = i;
Â  Â  Â  }
Â  Â  Â  else if(/^END\s*IF\b/i.test(t)) {
Â  Â  Â  Â  const top = stack.pop();
Â  Â  Â  Â  if(!top || top.type!=="IF") throw `END IF without IF at line ${i+1}`;
Â  Â  Â  Â  blocks.if[top.i] = blocks.if[top.i] || {};
Â  Â  Â  Â  blocks.if[top.i].end = i;
Â  Â  Â  }
Â  Â  Â  else if(/^REPEAT\s+\d+\s+TIMES\b/i.test(t)) {
Â  Â  Â  Â  stack.push({type:"RT", i});
Â  Â  Â  }
Â  Â  Â  else if(/^REPEAT\s+UNTIL\b/i.test(t)) {
Â  Â  Â  Â  stack.push({type:"RU", i});
Â  Â  Â  }
Â  Â  Â  else if(/^END\s*REPEAT\b/i.test(t)) {
Â  Â  Â  Â  const top = stack.pop();
Â  Â  Â  Â  if(!top || (top.type!=="RT" && top.type!=="RU")) throw `END REPEAT without REPEAT at line ${i+1}`;
Â  Â  Â  Â  blocks.repStartToEnd[top.i] = i;
Â  Â  Â  Â  blocks.repEndToStart[i] = top.i;
Â  Â  Â  }
Â  Â  }
Â  Â  if(stack.length) throw `Unclosed block at line ${stack[0].i+1}`;
Â  Â  return blocks;
Â  }

Â  // ---------- Procedures table (MODIFIED TO FIND } AS END) ----------
Â  function parseProcedures(lines){
Â  Â  const procs = {};
Â  Â  let open = null;
Â  Â  for (let i=0;i<lines.length;i++){
Â  Â  Â  const t = lines[i].s;
Â  Â  Â  if(!t) continue;
Â  Â  Â  if(/^PROCEDURE\b/i.test(t)){
Â  Â  Â  Â  const m = t.match(/^PROCEDURE\s+([A-Za-z_]\w*)\s*\(([^)]*)\)\s*\{?\s*$/i);
Â  Â  Â  Â  if(!m) throw `Bad PROCEDURE syntax at line ${i+1}`;
Â  Â  Â  Â  if(open) throw `Nested PROCEDURE not allowed (line ${i+1})`;
Â  Â  Â  Â  open = { name: m[1], params: m[2].trim()? m[2].split(",").map(s=>s.trim()) : [], start: i+1, end: null };
Â  Â  Â  } else if(/^END\s+PROCEDURE\b/i.test(t) || t === "}"){ // <--- MODIFIED: Check for }
Â  Â  Â  Â  if(!open) throw `${t} without PROCEDURE at line ${i+1}`;
Â  Â  Â  Â  open.end = i;
Â  Â  Â  Â  procs[open.name] = open;
Â  Â  Â  Â  open = null;
Â  Â  Â  }
Â  Â  }
Â  Â  if(open) throw `Unclosed PROCEDURE '${open.name}' starting at line ${open.start}`;
Â  Â  return procs;
Â  }

Â  // ---------- Expression evaluator ----------
Â  function makeEval(env, procs){
Â  Â  const safe=/^[\w\s+\-*/%().,<>!=â€œâ€"'\[\]â‰¤â‰¥â‰ ?:]+$/u;
Â  Â  function rewrite(expr){
Â  Â  Â  return expr
Â  Â  Â  Â  .replace(/[â€œâ€]/g,'"')
Â  Â  Â  Â  .replace(/â‰¤/g,"<=").replace(/â‰¥/g,">=").replace(/â‰ /g,"!=")
Â  Â  Â  Â  .replace(/\bAND\b/gi,"&&").replace(/\bOR\b/gi,"||").replace(/\bNOT\b/gi,"!")
Â  Â  Â  Â  .replace(/\bLENGTH\s+OF\s+([A-Za-z_]\w*)/gi, "LENGTH($1)")
Â  Â  Â  Â  .replace(/([A-Za-z_]\w*)\s*\[\s*([^\]]+)\s*\]/g, "IDX($1,($2))");
Â  Â  }
Â  Â  const envWithProcs = new Proxy(env,{
Â  Â  Â  get(t,p){
Â  Â  Â  Â  if(p in t) return t[p];
Â  Â  Â  Â  const name = String(p);
Â  Â  Â  Â  if (procs[name]) {
Â  Â  Â  Â  Â  return async (...args)=> await callProc(name, args, env);
Â  Â  Â  Â  }
Â  Â  Â  Â  return undefined;
Â  Â  Â  }
Â  Â  });

Â  Â  async function callProc(name, args, callerEnv){
Â  Â  Â  const def = procs[name];
Â  Â  Â  if(!def) throw `Unknown procedure '${name}'`;
Â  Â  Â  const local = Object.create(callerEnv);
Â  Â  Â  for(let i=0;i<def.params.length;i++) local[def.params[i]] = args[i];
Â  Â  Â  const result = await execRange(def.start, def.end, local, true);
Â  Â  Â  return result.__ret ?? null;
Â  Â  }

Â  Â  return async function evalExpr(expr){
Â  Â  Â  const e = rewrite(expr);
Â  Â  Â  if(!safe.test(e)) throw "Expression contains unsupported characters";
Â  Â  Â  const INPUT = async prompt => showPrompt(prompt||"Input");
Â  Â  Â  const APPEND=(L,v)=>L.push(v), INSERT=(L,i,v)=>L.splice(i-1,0,v), REMOVE=(L,i)=>L.splice(i-1,1), LENGTH=L=>L.length, IDX=(L,i)=>L[(i|0)-1];
Â  Â  Â  const fn = new Function("env","Math","INPUT","APPEND","INSERT","REMOVE","LENGTH","IDX",
Â  Â  Â  Â  `with(env){ return ( ${e} ); }`);
Â  Â  Â  return await fn(envWithProcs, Math, INPUT, APPEND, INSERT, REMOVE, LENGTH, IDX);
Â  Â  };
Â  }

Â  // ---------- Globals for current program ----------
Â  let LINES=[], BLOCKS=null, PROCS=null, ENV=null, EVAL=null;

Â  // ---------- Executor (MODIFIED TO JUMP AND ALLOW BARE CALLS) ----------
Â  async function execRange(start, end, env, insideProc=false){
Â  Â  const evalExpr = (env===ENV ? EVAL : makeEval(env, PROCS));
Â  Â  let i = start;

Â  Â  // For REPEAT TIMES, keep map from start index to iteration count
Â  Â  env.__times = env.__times || {};

Â  Â  while(i < end){
Â  Â  Â  if(halted) return {__halt:true};
Â  Â  Â  const {s, idx} = LINES[i];
Â  Â  Â  i++;

Â  Â  Â  if(!s) continue;

Â  Â  Â  // Skip procedure bodies at top level (MODIFIED: Check for } as well)
Â  Â  Â  if(/^PROCEDURE\b/i.test(s)){
Â  Â  Â  Â  // Jump to recorded end
Â  Â  Â  Â  const m = s.match(/^PROCEDURE\s+([A-Za-z_]\w*)/i);
Â  Â  Â  Â  const name = m[1];
Â  Â  Â  Â  const def = PROCS[name];
Â  Â  Â  Â  i = (def.end + 1);
Â  Â  Â  Â  continue;
Â  Â  Â  }
Â  Â  Â  if(/^END\s+PROCEDURE\b/i.test(s) || s === "}"){ // <--- MODIFIED: Check for }
Â  Â  Â  Â  if(insideProc) return {__ret:null};
Â  Â  Â  Â  continue;
Â  Â  Â  }

Â  Â  Â  // DISPLAY(expr)
Â  Â  Â  if(/^DISPLAY\s*\(/i.test(s)){
Â  Â  Â  Â  const m = s.match(/^DISPLAY\s*\((.*)\)\s*$/i);
Â  Â  Â  Â  if(!m) throw `DISPLAY syntax at line ${idx+1}`;
Â  Â  Â  Â  log(await evalExpr(m[1]));
Â  Â  Â  Â  continue;
Â  Â  Â  }

Â  Â  Â  // SET x â† expr Â OR x â† expr (strict allows assignment without SET if arrow used)
Â  Â  Â  if(/^(SET\s+)?[A-Za-z_]\w*\s*(â†|<-)/.test(s)){
Â  Â  Â  Â  const m = s.match(/^(?:SET\s+)?([A-Za-z_]\w*)\s*(?:â†|<-)\s*(.*)$/i);
Â  Â  Â  Â  ENV[m[1]] = await evalExpr(m[2]);
Â  Â  Â  Â  continue;
Â  Â  Â  }

Â  Â  Â  // IF / ELSE / END IF
Â  Â  Â  if(/^IF\b/i.test(s)){
Â  Â  Â  Â  const cond = s.replace(/^IF\b/i,"").replace(/\bTHEN\b/i,"").trim();
Â  Â  Â  Â  const ok = await evalExpr(cond);
Â  Â  Â  Â  const meta = BLOCKS.if[idx];
Â  Â  Â  Â  if(!meta) throw `IF without END IF at line ${idx+1}`;
Â  Â  Â  Â  if(!ok){
Â  Â  Â  Â  Â  i = (meta.else!=null ? meta.else+1 : meta.end+1);
Â  Â  Â  Â  }
Â  Â  Â  Â  continue;
Â  Â  Â  }
Â  Â  Â  if(/^ELSE\b/i.test(s)){ // jump to END IF
Â  Â  Â  Â  const startIf = [...Object.keys(BLOCKS.if).map(k=>+k)].reverse().find(k=>k<idx);
Â  Â  Â  Â  i = BLOCKS.if[startIf].end + 1;
Â  Â  Â  Â  continue;
Â  Â  Â  }
Â  Â  Â  if(/^END\s*IF\b/i.test(s)){ continue; }

Â  Â  Â  // REPEAT n TIMES
Â  Â  Â  if(/^REPEAT\s+\d+\s+TIMES\b/i.test(s)){
Â  Â  Â  Â  const m = s.match(/^REPEAT\s+(\d+)\s+TIMES\b/i);
Â  Â  Â  Â  const n = parseInt(m[1],10);
Â  Â  Â  Â  // Do nothing here; loop handled at END REPEAT
Â  Â  Â  Â  continue;
Â  Â  Â  }

Â  Â  Â  // REPEAT UNTIL cond â€” store condition string at this start
Â  Â  Â  if(/^REPEAT\s+UNTIL\b/i.test(s)){
Â  Â  Â  Â  const cond = s.replace(/^REPEAT\s+UNTIL\b/i,"").trim();
Â  Â  Â  Â  ENV[`__until_${idx}`] = cond;
Â  Â  Â  Â  continue;
Â  Â  Â  }

Â  Â  Â  // END REPEAT
Â  Â  Â  if(/^END\s*REPEAT\b/i.test(s)){
Â  Â  Â  Â  const startIdx = BLOCKS.repEndToStart[idx];
Â  Â  Â  Â  const startLine = LINES[startIdx].s;

Â  Â  Â  Â  if(/^REPEAT\s+\d+\s+TIMES\b/i.test(startLine)){
Â  Â  Â  Â  Â  const m = startLine.match(/^REPEAT\s+(\d+)\s+TIMES\b/i);
Â  Â  Â  Â  Â  const n = parseInt(m[1],10);
Â  Â  Â  Â  Â  ENV.__times[startIdx] = (ENV.__times[startIdx] || 0) + 1;
Â  Â  Â  Â  Â  if(ENV.__times[startIdx] < n){
Â  Â  Â  Â  Â  Â  i = startIdx + 1; // loop again
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  delete ENV.__times[startIdx];
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else { // REPEAT UNTIL (post-check)
Â  Â  Â  Â  Â  const cond = ENV[`__until_${startIdx}`];
Â  Â  Â  Â  Â  const ok = await evalExpr(cond);
Â  Â  Â  Â  Â  if(!ok){ i = startIdx + 1; } // keep looping until condition true
Â  Â  Â  Â  }
Â  Â  Â  Â  continue;
Â  Â  Â  }

Â  Â  Â  // CALL name(args) â€” now optional for statement calls (MODIFIED)
Â  Â  Â  if(/^CALL\s+[A-Za-z_]\w*\s*\(/i.test(s)){
Â  Â  Â  Â  const call = s.replace(/^CALL\s+/i, "");
Â  Â  Â  Â  await evalExpr(call); // value is discarded
Â  Â  Â  Â  continue;
Â  Â  Â  }

Â  Â  Â  // Allow bare procedure calls as a statement (MODIFIED)
Â  Â  Â  if(/^[A-Za-z_]\w*\s*\(/.test(s)){
Â  Â  Â  Â  const m = s.match(/^([A-Za-z_]\w*)\s*\(/);
Â  Â  Â  Â  if(PROCS[m[1]]){
Â  Â  Â  Â  Â  await evalExpr(s);
Â  Â  Â  Â  Â  continue;
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  // Standalone expressions are NOT allowed in strict mode (except INPUT for side-effect)
Â  Â  Â  if(/^INPUT\s*\(/i.test(s)){ await evalExpr(s); continue; }
Â  Â  Â  
Â  Â  Â  // If the line is just a closing brace, ignore it (it was handled by parseProcedures for scope)
Â  Â  Â  if(s === "}"){ continue; }

Â  Â  Â  throw `Unknown statement at line ${idx+1}: ${s}`;
Â  Â  }
Â  Â  return {__ret:null};
Â  }

Â  // ---------- Run ----------
Â  async function run(src){
Â  Â  halted=false; logEl.innerHTML=""; setStatus("Parsingâ€¦");
Â  Â  try{
Â  Â  Â  LINES = preprocess(src);
Â  Â  Â  BLOCKS = buildBlocks(LINES);
Â  Â  Â  PROCS Â = parseProcedures(LINES);
Â  Â  Â  ENV = Object.create(null);
Â  Â  Â  EVAL = makeEval(ENV, PROCS);
Â  Â  }catch(e){ err(e); setStatus("Crashed"); return; }

Â  Â  setStatus("Runningâ€¦");
Â  Â  try{
Â  Â  Â  // Find the end of the program, excluding any procedure definitions at the end
Â  Â  Â  let programEnd = LINES.length;
Â  Â  Â  // A simple approach: run from line 0 until the end. Since execRange is now smarter 
Â  Â  Â  // about skipping procedure bodies, we can keep the range simple.
Â  Â  Â  await execRange(0, programEnd, ENV, false);
Â  Â  Â  setStatus("Finished");
Â  Â  }catch(e){ err(e); setStatus("Crashed"); }
Â  }

Â  // ---------- UI ----------
Â  $("#runBtn").onclick = ()=> run(editor.value);
Â  $("#stopBtn").onclick = ()=> { halted=true; setStatus("Stoppingâ€¦"); };
Â  document.addEventListener("keydown", e=>{
Â  Â  if((e.ctrlKey||e.metaKey) && e.key==="Enter"){ e.preventDefault(); $("#runBtn").click(); }
Â  });

Â  // Samples
Â  const samples = {
"Relaxed: Procedure + Braces": // New sample for the new syntax
`PROCEDURE hello() {
  DISPLAY("hello")
}

hello()`,

"Strict: Procedure + CALL":
`PROCEDURE greet()
Â  DISPLAY("hello")
END PROCEDURE

CALL greet()`,

"Strict: RETURN in expression":
`PROCEDURE pay(hours, rate)
Â  RETURN hours * rate
END PROCEDURE

SET paycheck â† pay(12, 18.5)
DISPLAY("Pay = $" + paycheck)`,

"Strict: REPEAT TIMES / UNTIL":
`REPEAT 3 TIMES
Â  DISPLAY("tick")
END REPEAT

SET i â† 0
REPEAT UNTIL i â‰¥ 3
Â  DISPLAY(i)
Â  SET i â† i + 1
END REPEAT`
Â  };

Â  const sel = $("#samples");
Â  sel.innerHTML = '<option value="">Load sampleâ€¦</option>' +
Â  Â  Object.keys(samples).map(k=>`<option>${k}</option>`).join('');
Â  sel.onchange = e=>{ const k=e.target.value; if(samples[k]) editor.value=samples[k]; e.target.value=""; };

Â  // Start with the relaxed sample
Â  editor.value = samples["Relaxed: Procedure + Braces"];

Â  setStatus("Ready"); sys("Relaxed mode loaded. Braces {} and bare calls allowed.");
});
</script>
</body>
</html>
