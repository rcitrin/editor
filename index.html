<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Citrin's APCSP Console</title>
<style>
:root {
  --bg: #1e1e1e;
  --panel-bg: #252526;
  --border: #3c3c3c;
  --text-primary: #d4d4d4;
  --text-muted: #808080;
  --run-btn-bg: #5f9040;
  --run-btn-text: #ffffff;
  --stop-btn-bg: #a33b3b;
  --console-bg: #1e1e1e;
  --console-log: #d4d4d4;
  --console-err: #ff8c8c;
  --console-sys: #92a4c1;
  --editor-bg: #1e1e1e;
  --editor-text: #d4d4d4;
  --editor-caret: #aeafad;
}
* { box-sizing: border-box; }
body {
  margin: 0;
  background: var(--bg);
  color: var(--text-primary);
  font: 16px/1.45 'JetBrains Mono', 'Fira Code', ui-monospace, Menlo, Consolas, monospace;
  display: flex;
  flex-direction: column;
  height: 100vh;
}
header {
  padding: 10px 15px;
  border-bottom: 1px solid var(--border);
  background: var(--panel-bg);
  color: var(--text-primary);
  font-size: 16px;
  font-weight: bold;
  flex-shrink: 0;
}
header span {
  font-weight: normal;
  color: var(--text-muted);
}
main {
  flex-grow: 1;
  display: grid;
  grid-template-columns: 1.1fr 0.9fr;
  gap: 10px;
  padding: 10px;
  min-height: 0;
}
.card {
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  min-height: 0;
}
.card h2 {
  font-size: 14px;
  margin: 0;
  padding: 8px 12px;
  color: var(--text-primary);
  border-bottom: 1px solid var(--border);
  background: #333333;
  flex-shrink: 0;
}
.toolbar {
  display: flex;
  gap: 8px;
  padding: 8px 12px;
  border-bottom: 1px solid var(--border);
  align-items: center;
  flex-wrap: wrap;
  flex-shrink: 0;
}
button, select {
  background: #3c3f41;
  color: var(--text-primary);
  border: 1px solid var(--border);
  padding: 6px 10px;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 500;
  font-size: 13px;
}
button.primary {
  background: var(--run-btn-bg);
  color: var(--run-btn-text);
  border-color: var(--run-btn-bg);
}
button.danger {
  background: var(--stop-btn-bg);
  color: var(--run-btn-text);
  border-color: var(--stop-btn-bg);
}
textarea {
  flex-grow: 1;
  width: 100%;
  height: 100%; 
  resize: none; 
  background: var(--editor-bg);
  color: var(--editor-text);
  border: 0;
  outline: none;
  padding: 12px 14px;
  font: 14px/1.45 'JetBrains Mono', 'Fira Code', ui-monospace, Menlo, Consolas, monospace;
  caret-color: var(--editor-caret);
  overflow: auto;
}
.console {
  flex-grow: 1;
  overflow: auto;
  padding: 12px;
  font: 14px/1.5 'JetBrains Mono', 'Fira Code', ui-monospace, Menlo, Consolas, monospace;
  background: var(--console-bg);
  white-space: pre-wrap;
}
.log { color: var(--console-log); }
.err { color: var(--console-err); }
.sys { color: var(--console-sys); }
.prompt-wrap { display: none; gap: 8px; padding: 10px; border-top: 1px solid var(--border); background: var(--panel-bg); align-items: center; flex-shrink: 0; }
.prompt-wrap input { flex: 1; background: #3c3f41; color: var(--text-primary); border: 1px solid var(--border); border-radius: 4px; padding: 8px 10px; }
.prompt-wrap.show { display: flex; }
.status { padding: 8px 12px; font-size: 12px; color: var(--text-muted); border-top: 1px solid var(--border); background: var(--panel-bg); flex-shrink: 0; }
footer {
  color: var(--text-muted);
  text-align: center;
  font-size: 12px;
  padding: 10px;
  background: var(--panel-bg);
  border-top: 1px solid var(--border);
  flex-shrink: 0;
}
</style>
</head>

<body>
<header>
  Citrin's APCSP Console <span>(Version 1.0)</span>
</header>

<main>
  <section class="card">
     <h2>Program</h2>
    <div class="toolbar">
      <button class="primary" id="runBtn">▶ Run</button>
      <button id="stopBtn" class="danger">■ Stop</button>
      <select id="samples"></select>
      <span style="margin-left:auto; color: var(--text-muted); font-size: 13px;">Ctrl/⌘ + Enter</span>
    </div>
    <textarea id="editor"></textarea>
  </section>

  <section class="card">
    <h2>Console</h2>
    <div class="console" id="console"></div>
    <div class="prompt-wrap" id="promptWrap">
      <input id="promptInput" placeholder="Enter input…" />
      <button id="promptOk">OK</button>
      <button id="promptCancel">Cancel</button>
    </div>
    <div class="status" id="status">Idle</div>
  </section>
</main>

<footer>AP CSP Emulator</footer>

<script>
window.addEventListener("DOMContentLoaded", () => {
  const $ = s => document.querySelector(s);

  // UI Elements
  const logEl = $("#console"), statusEl = $("#status"), editor = $("#editor");
  const promptWrap = $("#promptWrap"), promptInput = $("#promptInput");
  const promptOk = $("#promptOk"), promptCancel = $("#promptCancel");
  let halted = false, inputResolve=null, inputReject=null;

  const out=(m,c="log")=>{const d=document.createElement("div");d.className="line "+c;d.textContent=String(m);logEl.appendChild(d);logEl.scrollTop=logEl.scrollHeight;}
  const log=m=>out(m,"log"), err=m=>out(m,"err"), sys=m=>out(m,"sys");
  const setStatus = s => statusEl.textContent = s;

  function showPrompt(label){ promptInput.value=""; promptInput.placeholder=label||"Input"; promptWrap.classList.add("show"); promptInput.focus(); return new Promise((res,rej)=>{inputResolve=res;inputReject=rej;}); }
  function hidePrompt(){ promptWrap.classList.remove("show"); }
  promptOk.onclick=()=>{ if(inputResolve){ inputResolve(promptInput.value); hidePrompt(); } };
  promptCancel.onclick=()=>{ if(inputReject){ inputReject("cancel"); hidePrompt(); } };
  promptInput.addEventListener("keydown", e=>{ if(e.key==="Enter")promptOk.click(); if(e.key==="Escape")promptCancel.click(); });

  // ---------- Preprocess ----------
  function preprocess(src){
    return src.split(/\r?\n/).map((raw,idx)=>{
      const s = raw
        .replace(/#.*$/,"").replace(/\/\/.*$/,"") 
        .replace(/\t/g,"    ").trim(); 
      return { idx, raw, s };
    });
  }

  // ---------- Block map (Brace-based) ----------
  function buildBlocks(lines){
    const blocks = {
      braceMatch: {}, // maps { line -> } line
      ifElse: {},     // maps IF line -> ELSE line
      elseEnd: {},    // maps ELSE line -> } line (relative to ELSE line)
      loopStart: {},  // maps { line -> REPEAT/FOR EACH line
    };
    const stack = []; // To track open {
    const ifStack = []; // To track open IFs

    for (let i = 0; i < lines.length; i++) {
      const s = lines[i].s;
      if (!s) continue;

      if (/^IF\s*\((.*)\)/i.test(s)) {
        ifStack.push(i);
      } else if (s === "ELSE") {
        const ifLine = ifStack.pop();
        if (ifLine == null) throw `ELSE without IF at line ${i + 1}`;
        blocks.ifElse[ifLine] = i;
      } else if (s === "{") {
        stack.push(i);
      } else if (s === "}") {
        const openBraceLine = stack.pop();
        if (openBraceLine == null) throw `} without { at line ${i + 1}`;
        blocks.braceMatch[openBraceLine] = i;
        
        let tempStartLine = openBraceLine - 1;
        while(tempStartLine > 0 && lines[tempStartLine].s === "") {
          tempStartLine--;
        }
        const blockStartLineText = lines[tempStartLine].s;

        if (/^ELSE/i.test(blockStartLineText)) {
          blocks.elseEnd[tempStartLine] = i;
        } else if (/^REPEAT/i.test(blockStartLineText) || /^FOR EACH/i.test(blockStartLineText)) {
          blocks.loopStart[openBraceLine] = tempStartLine;
        }
      }
    }
    if (stack.length) throw `Unclosed block at line ${stack[0] + 1}`;
    return blocks;
  }

  // ---------- Procedures table (FIXED) ----------
  function parseProcedures(lines){
    const procs = {};
    let open = null;
    for (let i = 0; i < lines.length; i++){
      const t = lines[i].s;
      if(!t) continue;
      if(/^PROCEDURE\b/i.test(t)){
        const m = t.match(/^PROCEDURE\s+([A-Za-z_]\w*)\s*\(([^)]*)\)/i);
        if(!m) throw `Bad PROCEDURE syntax at line ${i+1}`;
        if(open) throw `Nested PROCEDURE not allowed (line ${i+1})`; 
        open = { name: m[1], params: m[2].trim()? m[2].split(",").map(s=>s.trim()) : [], start: i + 1, end: null };
      } else if(t === "{") {
          if (open && open.start === i) {
            open.start = i + 1; // Body starts *after* the brace
          }
      } else if(t === "}") {
        if(open && open.end === null) {
          open.end = i; // The line index of }
          procs[open.name] = open;
          open = null;
        }
      }
    }
    return procs;
  }

  // ---------- Expression evaluator (All fixes applied) ----------
  function makeEval(env, procs){
    const safe=/^[\w\s+\-*/%().,<>!=“”"'\[\]≤≥≠?:&|]+$/u;
    
    function rewrite(expr){
      return expr
        .replace(/[“”]/g,'"')
        .replace(/≤/g,"<=").replace(/≥/g,">=").replace(/≠/g,"!=")
        .replace(/\bAND\b/g,"&&").replace(/\bOR\b/g,"||").replace(/\bNOT\b/g,"!")
        .replace(/\bLENGTH\s*\(([^)]+)\)/gi, "LENGTH($1)")
        .replace(/([A-Za-z_]\w*)\s*\[\s*([^\]]+)\s*\]/g, "IDX($1,($2))");
    }

    async function callProc(name, args, callerEnv){
      const def = procs[name];
      if(!def) throw `Unknown procedure '${name}'`;
      const local = Object.create(callerEnv);
      for(let i=0;i<def.params.length;i++) local[def.params[i]] = args[i];
      const result = await execRange(def.start, def.end, local, true); 
      return result.__ret ?? null;
    }

    return async function evalExpr(expr){
      const e = rewrite(expr);
      if(!safe.test(e)) throw `Expression contains unsupported characters: ${e}`;

      // --- Build explicit scope ---
      const scope = {
          ...env, 
          Math,
          RANDOM: (a, b) => Math.floor(Math.random() * (b - a + 1)) + a,
          INPUT: async () => showPrompt("Input"), 
          APPEND: (L,v)=>{ if(!Array.isArray(L)) throw "APPEND target is not a list"; L.push(v); },
          INSERT: (L,i,v)=>{ if(!Array.isArray(L)) throw "INSERT target is not a list"; L.splice(i-1,0,v); },
          REMOVE: (L,i)=>{ if(!Array.isArray(L)) throw "REMOVE target is not a list"; L.splice(i-1,1); },
          LENGTH: L=>{ if(L == null) throw "LENGTH target is null"; if(!Array.isArray(L)) throw "LENGTH target is not a list"; return L.length; },
          IDX: (L,i)=>{
            if(L == null) throw "List index target is null";
            if(!Array.isArray(L)) throw "List index target is not a list";
            if (i < 1 || i > L.length) throw `Invalid index: ${i} for list of length ${L.length}`;
            return L[i-1];
          }
      };
      
      // **** SCOPE FIX ****
      let currentEnv = env;
      while (currentEnv && currentEnv !== Object.prototype) {
        for (const key of Object.getOwnPropertyNames(currentEnv)) {
            if (!scope.hasOwnProperty(key)) {
                scope[key] = currentEnv[key];
            }
        }
        currentEnv = Object.getPrototypeOf(currentEnv);
      }
      
      for (const name in procs) {
          if (!scope.hasOwnProperty(name)) {
            scope[name] = async (...args) => await
