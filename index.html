<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Citrin's APCSP Console</title>
<style>
:root {
  --bg: #1e1e1e;
  --panel-bg: #252526;
  --border: #3c3c3c;
  --text-primary: #d4d4d4;
  --text-muted: #808080;
  --run-btn-bg: #5f9040;
  --run-btn-text: #ffffff;
  --stop-btn-bg: #a33b3b;
  --console-bg: #1e1e1e;
  --console-log: #d4d4d4;
  --console-err: #ff8c8c;
  --console-sys: #92a4c1;
  --editor-bg: #1e1e1e;
  --editor-text: #d4d4d4;
  --editor-caret: #aeafad;
}
* { box-sizing: border-box; }
body {
  margin: 0;
  background: var(--bg);
  color: var(--text-primary);
  font: 16px/1.45 'JetBrains Mono', 'Fira Code', ui-monospace, Menlo, Consolas, monospace;
  display: flex;
  flex-direction: column;
  height: 100vh;
}
header {
  padding: 10px 15px;
  border-bottom: 1px solid var(--border);
  background: var(--panel-bg);
  color: var(--text-primary);
  font-size: 16px;
  font-weight: bold;
  flex-shrink: 0;
}
header span {
  font-weight: normal;
  color: var(--text-muted);
}
main {
  flex-grow: 1;
  display: grid;
  grid-template-columns: 1.1fr 0.9fr;
  gap: 10px;
  padding: 10px;
  min-height: 0;
}
.card {
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  min-height: 0;
}
.card h2 {
  font-size: 14px;
  margin: 0;
  padding: 8px 12px;
  color: var(--text-primary);
  border-bottom: 1px solid var(--border);
  background: #333333;
  flex-shrink: 0;
}
.toolbar {
  display: flex;
  gap: 8px;
  padding: 8px 12px;
  border-bottom: 1px solid var(--border);
  align-items: center;
  flex-wrap: wrap;
  flex-shrink: 0;
}
button, select {
  background: #3c3f41;
  color: var(--text-primary);
  border: 1px solid var(--border);
  padding: 6px 10px;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 500;
  font-size: 13px;
}
button.primary {
  background: var(--run-btn-bg);
  color: var(--run-btn-text);
  border-color: var(--run-btn-bg);
}
button.danger {
  background: var(--stop-btn-bg);
  color: var(--run-btn-text);
  border-color: var(--stop-btn-bg);
}
textarea {
  flex-grow: 1;
  width: 100%;
  height: 100%; 
  resize: none; 
  background: var(--editor-bg);
  color: var(--editor-text);
  border: 0;
  outline: none;
  padding: 12px 14px;
  font: 14px/1.45 'JetBrains Mono', 'Fira Code', ui-monospace, Menlo, Consolas, monospace;
  caret-color: var(--editor-caret);
  overflow: auto;
}
.console {
  flex-grow: 1;
  overflow: auto;
  padding: 12px;
  font: 14px/1.5 'JetBrains Mono', 'Fira Code', ui-monospace, Menlo, Consolas, monospace;
  background: var(--console-bg);
  white-space: pre-wrap;
}
.log { color: var(--console-log); }
.err { color: var(--console-err); }
.sys { color: var(--console-sys); }
.prompt-wrap { display: none; gap: 8px; padding: 10px; border-top: 1px solid var(--border); background: var(--panel-bg); align-items: center; flex-shrink: 0; }
.prompt-wrap input { flex: 1; background: #3c3f41; color: var(--text-primary); border: 1px solid var(--border); border-radius: 4px; padding: 8px 10px; }
.prompt-wrap.show { display: flex; }
.status { padding: 8px 12px; font-size: 12px; color: var(--text-muted); border-top: 1px solid var(--border); background: var(--panel-bg); flex-shrink: 0; }
footer {
  color: var(--text-muted);
  text-align: center;
  font-size: 12px;
  padding: 10px;
  background: var(--panel-bg);
  border-top: 1px solid var(--border);
  flex-shrink: 0;
}
</style>
</head>

<body>
<header>
  Citrin's APCSP Console <span>(Version 1.0)</span>
</header>

<main>
  <section class="card">
     <h2>Program</h2>
    <div class="toolbar">
      <button class="primary" id="runBtn">▶ Run</button>
      <button id="stopBtn" class="danger">■ Stop</button>
      <select id="samples"></select>
      <span style="margin-left:auto; color: var(--text-muted); font-size: 13px;">Ctrl/⌘ + Enter</span>
    </div>
    <textarea id="editor"></textarea>
  </section>

  <section class="card">
    <h2>Console</h2>
    <div class="console" id="console"></div>
    <div class="prompt-wrap" id="promptWrap">
      <input id="promptInput" placeholder="Enter input…" />
      <button id="promptOk">OK</button>
      <button id="promptCancel">Cancel</button>
    </div>
    <div class="status" id="status">Idle</div>
  </section>
</main>

<footer>AP CSP Emulator</footer>

<script>
window.addEventListener("DOMContentLoaded", () => {
  const $ = s => document.querySelector(s);

  // UI Elements
  const logEl = $("#console"), statusEl = $("#status"), editor = $("#editor");
  const promptWrap = $("#promptWrap"), promptInput = $("#promptInput");
  const promptOk = $("#promptOk"), promptCancel = $("#promptCancel");
  let halted = false, inputResolve=null, inputReject=null;

  const out=(m,c="log")=>{const d=document.createElement("div");d.className="line "+c;d.textContent=String(m);logEl.appendChild(d);logEl.scrollTop=logEl.scrollHeight;}
  const log=m=>out(m,"log"), err=m=>out(m,"err"), sys=m=>out(m,"sys");
  const setStatus = s => statusEl.textContent = s;

  function showPrompt(label){ promptInput.value=""; promptInput.placeholder=label||"Input"; promptWrap.classList.add("show"); promptInput.focus(); return new Promise((res,rej)=>{inputResolve=res;inputReject=rej;}); }
  function hidePrompt(){ promptWrap.classList.remove("show"); }
  promptOk.onclick=()=>{ if(inputResolve){ inputResolve(promptInput.value); hidePrompt(); } };
  promptCancel.onclick=()=>{ if(inputReject){ inputReject("cancel"); hidePrompt(); } };
  promptInput.addEventListener("keydown", e=>{ if(e.key==="Enter")promptOk.click(); if(e.key==="Escape")promptCancel.click(); });

  // ---------- Preprocess ----------
  function preprocess(src){
    return src.split(/\r?\n/).map((raw,idx)=>{
      const s = raw
        .replace(/#.*$/,"").replace(/\/\/.*$/,"") 
        .replace(/\t/g,"    ").trim(); 
      return { idx, raw, s };
    });
  }

  // ---------- Block map (Brace-based) ----------
  function buildBlocks(lines){
    const blocks = {
      braceMatch: {}, // maps { line -> } line
      ifElse: {},     // maps IF line -> ELSE line
      elseEnd: {},    // maps ELSE line -> } line (relative to ELSE line)
      loopStart: {},  // maps { line -> REPEAT/FOR EACH line
    };
    const stack = []; // To track open {
    const ifStack = []; // To track open IFs

    for (let i = 0; i < lines.length; i++) {
      const s = lines[i].s;
      if (!s) continue;

      if (/^IF\s*\((.*)\)/i.test(s)) {
        ifStack.push(i);
      } else if (s === "ELSE") {
        const ifLine = ifStack.pop();
        if (ifLine == null) throw `ELSE without IF at line ${i + 1}`;
        blocks.ifElse[ifLine] = i;
      } else if (s === "{") {
        stack.push(i);
      } else if (s === "}") {
        const openBraceLine = stack.pop();
        if (openBraceLine == null) throw `} without { at line ${i + 1}`;
        blocks.braceMatch[openBraceLine] = i;
        
        let tempStartLine = openBraceLine - 1;
        while(tempStartLine > 0 && lines[tempStartLine].s === "") {
          tempStartLine--;
        }
        const blockStartLineText = lines[tempStartLine].s;

        if (/^ELSE/i.test(blockStartLineText)) {
          blocks.elseEnd[tempStartLine] = i;
        } else if (/^REPEAT/i.test(blockStartLineText) || /^FOR EACH/i.test(blockStartLineText)) {
          blocks.loopStart[openBraceLine] = tempStartLine;
        }
      }
    }
    if (stack.length) throw `Unclosed block at line ${stack[0] + 1}`;
    return blocks;
  }

  // ---------- Procedures table (FIXED) ----------
  function parseProcedures(lines){
    const procs = {};
    let open = null;
    for (let i = 0; i < lines.length; i++){
      const t = lines[i].s;
      if(!t) continue;
      if(/^PROCEDURE\b/i.test(t)){
        const m = t.match(/^PROCEDURE\s+([A-Za-z_]\w*)\s*\(([^)]*)\)/i);
        if(!m) throw `Bad PROCEDURE syntax at line ${i+1}`;
        if(open) throw `Nested PROCEDURE not allowed (line ${i+1})`; 
        open = { name: m[1], params: m[2].trim()? m[2].split(",").map(s=>s.trim()) : [], start: i + 1, end: null };
      } else if(t === "{") {
          if (open && open.start === i) {
            open.start = i + 1; // Body starts *after* the brace
          }
      } else if(t === "}") {
        if(open && open.end === null) {
          open.end = i; // The line index of }
          procs[open.name] = open;
          open = null;
        }
      }
    }
    return procs;
  }

  // ---------- Expression evaluator (All fixes applied) ----------
  function makeEval(env, procs){
    const safe=/^[\w\s+\-*/%().,<>!=“”"'\[\]≤≥≠?:&|]+$/u;
    
    function rewrite(expr){
      return expr
        .replace(/[“”]/g,'"')
        .replace(/≤/g,"<=").replace(/≥/g,">=").replace(/≠/g,"!=")
        .replace(/\bAND\b/g,"&&").replace(/\bOR\b/g,"||").replace(/\bNOT\b/g,"!")
        .replace(/\bLENGTH\s*\(([^)]+)\)/gi, "LENGTH($1)")
        .replace(/([A-Za-z_]\w*)\s*\[\s*([^\]]+)\s*\]/g, "IDX($1,($2))");
    }

    async function callProc(name, args, callerEnv){
      const def = procs[name];
      if(!def) throw `Unknown procedure '${name}'`;
      const local = Object.create(callerEnv);
      for(let i=0;i<def.params.length;i++) local[def.params[i]] = args[i];
      const result = await execRange(def.start, def.end, local, true); 
      return result.__ret ?? null;
    }

    return async function evalExpr(expr){
      const e = rewrite(expr);
      if(!safe.test(e)) throw `Expression contains unsupported characters: ${e}`;

      // --- Build explicit scope ---
      const scope = {
          ...env, 
          Math,
          RANDOM: (a, b) => Math.floor(Math.random() * (b - a + 1)) + a,
          INPUT: async () => showPrompt("Input"), 
          APPEND: (L,v)=>{ if(!Array.isArray(L)) throw "APPEND target is not a list"; L.push(v); },
          INSERT: (L,i,v)=>{ if(!Array.isArray(L)) throw "INSERT target is not a list"; L.splice(i-1,0,v); },
          REMOVE: (L,i)=>{ if(!Array.isArray(L)) throw "REMOVE target is not a list"; L.splice(i-1,1); },
          LENGTH: L=>{ if(L == null) throw "LENGTH target is null"; if(!Array.isArray(L)) throw "LENGTH target is not a list"; return L.length; },
          IDX: (L,i)=>{
            if(L == null) throw "List index target is null";
            if(!Array.isArray(L)) throw "List index target is not a list";
            if (i < 1 || i > L.length) throw `Invalid index: ${i} for list of length ${L.length}`;
            return L[i-1];
          }
      };
      
      // **** SCOPE FIX ****
      let currentEnv = env;
      while (currentEnv && currentEnv !== Object.prototype) {
        for (const key of Object.getOwnPropertyNames(currentEnv)) {
            if (!scope.hasOwnProperty(key)) {
                scope[key] = currentEnv[key];
            }
        }
        currentEnv = Object.getPrototypeOf(currentEnv);
      }
      
      for (const name in procs) {
          if (!scope.hasOwnProperty(name)) {
            scope[name] = async (...args) => await callProc(name, args, env);
          }
      }
      
      const scopeKeys = Object.keys(scope);
      const scopeValues = Object.values(scope);

      const body = `
        const MOD = (a, b) => a % b;
        return ( ${e} );
      `;
      const fn = new Function(...scopeKeys, body);
      return await fn(...scopeValues);
    };
  }

  // ---------- Globals for current program ----------
  let LINES=[], BLOCKS=null, PROCS=null, ENV=null, EVAL=null;

  // ---------- Executor (Rewritten for Braces) ----------
  async function execRange(start, end, env, insideProc=false){
    const evalExpr = (env===ENV ? EVAL : makeEval(env, PROCS));
    let i = start;
    
    env.__times = env.__times || {};
    env.__forEach = env.__forEach || {};

    while(i < end){ 
      if(halted) return {__halt:true};
      const {s, idx} = LINES[i];
      i++;
      if(!s) continue;
      
      if(s === "{") { continue; } // Skip opening braces

      // Skip procedure bodies (top level)
      if(!insideProc && /^PROCEDURE\b/i.test(s)){
        const m = s.match(/^PROCEDURE\s+([A-Za-z_]\w*)/i);
        const name = m[1];
        const def = PROCS[name];
        i = (def.end + 1); // Jump *past* the } line
        continue;
      }

      // Handle RETURN statement
      if(/^RETURN\s*\((.*)\)/i.test(s)){
        if(!insideProc) throw `RETURN statement outside of a PROCEDURE at line ${idx+1}`;
        const expr = s.match(/^RETURN\s*\((.*)\)/i)[1];
        if (!expr) return {__ret: null};
        const returnValue = await evalExpr(expr);
        return {__ret: returnValue};
      }
      
      // DISPLAY(expression)
      if(/^DISPLAY\s*\((.*)\)/i.test(s)){
        const expr = s.match(/^DISPLAY\s*\((.*)\)/i)[1];
        log(await evalExpr(expr));
        continue;
      }
      
      // a <- expression
      if(/^(SET\s+)?[A-Za-z_]\w*\s*(←|<-)\s*(.*)$/.test(s)){
        const m = s.match(/^(?:SET\s+)?([A-Za-z_]\w*)\s*(?:←|<-)\s*(.*)$/i);
        const varName = m[1];
        const expr = m[2];
        const val = await evalExpr(expr);
        
        // **** SCOPE FIX ****
        let targetEnv = env;
        while(targetEnv) {
            if (Object.prototype.hasOwnProperty.call(targetEnv, varName)) {
                break; 
            }
            if (targetEnv === ENV || !Object.getPrototypeOf(targetEnv)) {
                targetEnv = null; 
                break;
            }
            targetEnv = Object.getPrototypeOf(targetEnv);
        }

        if (targetEnv) {
            targetEnv[varName] = val; // Found it, update it
        } else {
            env[varName] = val; // Not found anywhere, create in *current* env
        }
        
        continue;
      }
      
      // IF (condition)
      if(/^IF\s*\((.*)\)/i.test(s)){
        const cond = s.match(/^IF\s*\((.*)\)/i)[1];
        const ok = await evalExpr(cond);
        const nextLine = LINES[i].s; 
        if (nextLine !== "{") throw `IF at line ${idx+1} must be followed by {`;
        
        const endBrace = BLOCKS.braceMatch[i];
        if(!ok){
          const elseLine = BLOCKS.ifElse[idx];
          if (elseLine != null) {
            i = elseLine; // Jump to ELSE
          } else {
            i = endBrace + 1; // Jump past }
          }
        }
        continue;
      }
      
      // ELSE
      if(s === "ELSE") {
        const nextLine = LINES[i].s;
        if (nextLine !== "{") throw `ELSE at line ${idx+1} must be followed by {`;
        const endBrace = BLOCKS.elseEnd[idx];
        i = endBrace + 1; // Jump past ELSE's }
        continue;
      }
      
      // REPEAT n TIMES
      if(/^REPEAT\s+(.*)\s+TIMES/i.test(s)){
        const expr = s.match(/^REPEAT\s+(.*)\s+TIMES/i)[1];
        const n = await evalExpr(expr);
        const nextLine = LINES[i].s;
        if (nextLine !== "{") throw `REPEAT at line ${idx+1} must be followed by {`;
        
        const count = (env.__times[i] || 0) + 1;
        env.__times[i] = count;
        
        if (count > n) {
          delete env.__times[i];
          i = BLOCKS.braceMatch[i] + 1; // Jump past }
        }
        continue;
      }
      
      // REPEAT UNTIL (condition)
      if(/^REPEAT\s+UNTIL\s*\((.*)\)/i.test(s)) {
        const nextLine = LINES[i].s;
        if (nextLine !== "{") throw `REPEAT UNTIL at line ${idx+1} must be followed by {`;
        continue;
      }
      
      // FOR EACH item IN aList (FIXED Regex)
      if(/^FOR EACH\s+(\w+)\s+IN\s+(.*)/i.test(s)) {
        const m = s.match(/^FOR EACH\s+(\w+)\s+IN\s+(.*)/i);
        const itemVar = m[1];
        const listExpr = m[2]; // Was listVar
        
        const nextLine = LINES[i].s;
        if (nextLine !== "{") throw `FOR EACH at line ${idx+1} must be followed by {`;

        const state = env.__forEach[i] || { index: 0, list: null };
        if (state.list === null) {
          state.list = await evalExpr(listExpr); // Was listVar
        }
        
        if (state.index < state.list.length) {
          env[itemVar] = state.list[state.index]; 
          state.index++;
          env.__forEach[i] = state; 
        } else {
          delete env.__forEach[i];
          delete env[itemVar]; 
          i = BLOCKS.braceMatch[i] + 1; // Jump past }
        }
        continue;
      }

      // } (Closing brace) - **** LOGIC FIXED ****
      if(s === "}") {
        // This } could be for an IF, ELSE, REPEAT, FOR EACH, or PROCEDURE
        
        // First, check if it's a loop's }
        const openBraceLine = Object.keys(BLOCKS.braceMatch).find(k => BLOCKS.braceMatch[k] === idx);
        
        if (openBraceLine) {
            const startLineIdx = BLOCKS.loopStart[openBraceLine];
            if (startLineIdx != null) {
              // This IS a loop's }
              const startLine = LINES[startLineIdx].s;
              
              if (/^REPEAT\s+UNTIL/i.test(startLine)) {
                const cond = startLine.match(/^REPEAT\s+UNTIL\s*\((.*)\)/i)[1];
                const ok = await evalExpr(cond);
                if (!ok) {
                  i = openBraceLine; // Jump back to {
                }
                continue; // Continue the while loop
              } else if (/^REPEAT\s+.*TIMES/i.test(startLine)) {
                i = startLineIdx; // Jump back to REPEAT line
                continue;
              } else if (/^FOR EACH/i.test(startLine)) {
                i = startLineIdx; // Jump back to FOR EACH line
                continue;
              }
            }
        }
        
        // If it wasn't a loop brace, it's an IF/ELSE/PROC brace.
        // The procedure end is handled by the `while(i < end)` condition.
        // IF/ELSE braces should just continue.
        continue;
      }

      // List operations
      if(/^(APPEND|INSERT|REMOVE)\s*\(/.test(s)) {
        await evalExpr(s); 
        continue;
      }
      
      // Procedure call (bare)
      if(/^[A-Za-z_]\w*\s*\((.*)\)/.test(s)){
        const match = s.match(/^([A-Za-z_]\w*)/);
        if(match && PROCS[match[1]]){
          await evalExpr(s);
          continue;
        }
      }

      throw `Unknown statement at line ${idx+1}: ${s}`;
    }
    return {__ret:null};
  }

  // ---------- Run ----------
  async function run(src){
    halted=false; logEl.innerHTML=""; setStatus("Parsing…");
    try{
      LINES = preprocess(src);
      BLOCKS = buildBlocks(LINES);
      PROCS  = parseProcedures(LINES);
      ENV = Object.create(null); // Global env is clean
      EVAL = makeEval(ENV, PROCS);
    }catch(e){ err(e); setStatus("Crashed"); return; }

    setStatus("Running…");
    try{
      await execRange(0, LINES.length, ENV, false);
      setStatus("Finished");
    }catch(e){ err(e); setStatus("Crashed"); }
  }

  // ---------- UI ----------
  $("#runBtn").onclick = ()=> run(editor.value);
  $("#stopBtn").onclick = ()=> { halted=true; setStatus("Stopping…"); };
  document.addEventListener("keydown", e=>{
    if((e.ctrlKey||e.metaKey) && e.key==="Enter"){ e.preventDefault(); $("#runBtn").click(); }
  });

  // Samples (NEW: All in correct AP CSP syntax)
  const samples = {
"Variables & Set":
`a <- 10
b <- "Hello"
DISPLAY(b + " world")
a <- a * 2
DISPLAY("The value of a is " + a)`,

"Selection (IF/ELSE)":
`age <- 17
IF (age >= 18)
{
  DISPLAY("You can vote.")
}
ELSE
{
  DISPLAY("You are not old enough to vote.")
}
IF (age < 13 AND age > 5)
{
  DISPLAY("You are a child.")
}`,

"Loops (REPEAT)":
`DISPLAY("--- REPEAT n TIMES ---")
REPEAT 3 TIMES
{
  DISPLAY("Hello!")
}

DISPLAY("--- REPEAT UNTIL ---")
count <- 0
REPEAT UNTIL (count > 2)
{
  DISPLAY("Count is " + count)
  count <- count + 1
}`,

"Procedures (Statements)":
`PROCEDURE greet(name)
{
  DISPLAY("Hello, " + name)
}

greet("Alice")
greet("Bob")`,

"Return Values":
`PROCEDURE square(n)
{
  RETURN (n * n)
}

num <- 7
numSquared <- square(num)
DISPLAY(num + " squared is " + numSquared)
DISPLAY("10 squared is " + square(10))`,

"Local Scope":
`PROCEDURE makeSquare()
{
  result <- square(10)
  DISPLAY("answer is " + result)
}

PROCEDURE square(n)
{
  RETURN (n * n)
}

makeSquare()`,

"List Processing & FOR EACH":
`myList <- [10, 20, 30]
DISPLAY(myList[1])
DISPLAY(LENGTH(myList))

FOR EACH item IN myList
{
  DISPLAY("Item: " + item)
}`,

"INPUT()":
`DISPLAY("What is your name?")
name <- INPUT()
DISPLAY("Hello, " + name)`
  };

  const sel = $("#samples");
  sel.innerHTML = '<option value="">Load sample…</option>' +
    Object.keys(samples).map(k=>`<option>${k}</option>`).join('');
  sel.onchange = e=>{ const k=e.target.value; if(samples[k]) editor.value=samples[k]; e.target.value=""; };

  // Start with a blank editor
  editor.value = "";

  setStatus("Ready"); sys("Emulator loaded. Awaiting run.");
});
</script>
</body>
</html>
