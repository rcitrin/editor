<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TBA PSEUDOCODE CONSOLE</title>

  <style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');


:root {
  --bg: #000000;
  --bg-elevated: #0a0a0a;
  --panel-bg: #111111;
  --panel-bg-hover: #1a1a1a;
  --border: #222222;
  --border-subtle: #1a1a1a;
  --text-primary: #f0f0f0;
  --text-secondary: #a0a0a0;
  --text-muted: #666666;

  --accent: #666666;
  --accent-hover: #999999;
  --accent-glow: rgba(101, 136, 26, 0.25);

  --danger: #B5514D;
  --danger-hover: #B5514D;

  --editor-caret: #519BB0;

  --gradient-1: linear-gradient(135deg, #A6253A 0%, #A6253A 100%);
  
  --btn-secondary-bg: #2a2a2a;
  --btn-secondary-border: #3a3a3a;
  --btn-secondary-hover: #383838;
}

body.light-mode {
  --bg: #f5f5f5;
  --bg-elevated: #ffffff;
  --panel-bg: #ffffff;
  --panel-bg-hover: #f0f0f0;
  --border: #d0d0d0;
  --text-primary: #1a1a1a;
  --text-secondary: #555555;
  --text-muted: #888888;
  --btn-secondary-bg: #e8e8e8;
  --btn-secondary-border: #ccc;
  --btn-secondary-hover: #ddd;
}
* { box-sizing: border-box; margin: 0; padding: 0; }

html, body { 
  margin: 0; 
  padding: 0;
  height: 100%;
  overflow: hidden;
}

body {
  background: var(--bg);
  color: var(--text-primary);
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  font-size: 14px;
  line-height: 1.5;
  display: flex;
  flex-direction: column;
  height: 100vh;
}

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-track {
  background: var(--bg);
}
::-webkit-scrollbar-thumb {
  background: #333;
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background: #444;
}

header {
  padding: 16px 24px;
  background: var(--bg);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-shrink: 0;
}

.logo {
  display: flex;
  align-items: center;
  gap: 12px;
}

.logo-icon {
  width: 36px;
  height: 36px;
  background: #a855f7;
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 18px;
  color: #000;
  box-shadow: 0 4px 12px var(--accent-glow);
}

.logo-text {
  font-size: 18px;
  font-weight: 600;
  letter-spacing: -0.5px;
}

.logo-text span {
  background: var(--gradient-1);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.header-actions {
  display: flex;
  gap: 8px;
}

main {
  flex: 1;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1px;
  background: var(--border);
  min-height: 0;
  position: relative;
}

.resizer {
  position: absolute;
  width: 12px;
  height: 100%;
  background: transparent;
  cursor: col-resize;
  top: 0;
  left: calc(50% - 6px);
  z-index: 100;
  display: flex;
  align-items: center;
  justify-content: center;
}

.resizer::after {
  content: '';
  width: 4px;
  height: 48px;
  background: var(--border);
  border-radius: 2px;
  transition: all 0.2s ease;
}

.resizer:hover::after {
  background: var(--accent);
  height: 64px;
  box-shadow: 0 0 12px var(--accent-glow);
}

.panel {
  background: var(--panel-bg);
  display: flex;
  flex-direction: column;
  min-height: 0;
  overflow: hidden;
}

.panel-header {
  padding: 12px 16px;
  background: var(--bg);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.panel-header h2 {
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--text-muted);
  margin: 0;
}

.panel-header .dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--accent);
  box-shadow: 0 0 8px var(--accent);
}

.toolbar {
  padding: 12px 16px;
  background: var(--bg-elevated);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  flex-shrink: 0;
}

.toolbar-group {
  display: flex;
  gap: 6px;
}

.toolbar-divider {
  width: 1px;
  height: 28px;
  background: var(--border);
  margin: 0 8px;
}

button {
  font-family: 'Inter', sans-serif;
  font-size: 13px;
  font-weight: 500;
  padding: 8px 14px;
  border-radius: 8px;
  border: 1px solid var(--border);
  background: var(--panel-bg);
  color: var(--text-primary);
  cursor: pointer;
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  gap: 6px;
}

button:hover {
  background: var(--panel-bg-hover);
  border-color: #333;
}

button.primary {
  background: var(--accent);
  border-color: var(--accent);
  color: #000;
  font-weight: 600;
}

button.primary:hover {
  background: var(--accent-hover);
  border-color: var(--accent-hover);
  box-shadow: 0 4px 12px var(--accent-glow);
}

button.danger {
  background: transparent;
  border-color: var(--danger);
  color: var(--danger);
}

button.danger:hover {
  background: var(--danger);
  color: #fff;
}

button.ghost {
  background: var(--btn-secondary-bg);
  border-color: var(--btn-secondary-border);
}

button.ghost:hover {
  background: var(--btn-secondary-hover);
  border-color: #4a4a4a;
}

.dropdown {
  position: relative;
}

.dropdown-trigger {
  min-width: 140px;
  justify-content: space-between;
}

.dropdown-trigger::after {
  content: '‚ñæ';
  font-size: 10px;
  opacity: 0.6;
}

.dropdown-menu {
  position: absolute;
  top: calc(100% + 4px);
  left: 0;
  min-width: 220px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 6px;
  box-shadow: 0 16px 48px rgba(0,0,0,0.5);
  z-index: 1000;
  display: none;
  max-height: 400px;
  overflow-y: auto;
}

.dropdown-menu.show {
  display: block;
  animation: dropdownIn 0.15s ease;
}

@keyframes dropdownIn {
  from { opacity: 0; transform: translateY(-8px); }
  to { opacity: 1; transform: translateY(0); }
}

.dropdown-category {
  padding: 8px 12px 6px;
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  gap: 8px;
}

.dropdown-category::after {
  content: '';
  flex: 1;
  height: 1px;
  background: var(--border);
}

.dropdown-item {
  padding: 10px 12px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 13px;
  color: var(--text-secondary);
  transition: all 0.1s ease;
  display: flex;
  align-items: center;
  gap: 10px;
}

.dropdown-item:hover {
  background: var(--panel-bg-hover);
  color: var(--text-primary);
}

.dropdown-item .icon {
  width: 20px;
  height: 20px;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  flex-shrink: 0;
}

.dropdown-item.cat-variables .icon { background: rgba(59, 130, 246, 0.2); color: #A6253A; }
.dropdown-item.cat-conditionals .icon { background: rgba(168, 85, 247, 0.2); color: #a855f7; }
.dropdown-item.cat-loops .icon { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
.dropdown-item.cat-procedures .icon { background: rgba(236, 72, 153, 0.2); color: #ec4899; }
.dropdown-item.cat-lists .icon { background: rgba(245, 158, 11, 0.2); color: #f59e0b; }
.dropdown-item.cat-strings .icon { background: rgba(6, 182, 212, 0.2); color: #06b6d4; }
.dropdown-item.cat-programs .icon { background: rgba(6, 182, 212, 0.2); color: #06b6d4; }

.editor-wrapper {
  flex: 1;
  display: flex;
  overflow: hidden;
  background: var(--editor-bg);
}

.line-numbers {
  padding: 16px 12px;
  background: var(--editor-bg);
  color: var(--text-muted);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 14px;
  line-height: 1.6;
  text-align: right;
  user-select: none;
  border-right: 1px solid var(--border);
  min-width: 48px;
  overflow: hidden;
  white-space: pre;
}

textarea {
  flex: 1;
  padding: 16px;
  background: var(--editor-bg);
  color: var(--editor-text);
  border: none;
  outline: none;
  resize: none;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 14px;
  line-height: 1.6;
  caret-color: var(--editor-caret);
  overflow: auto;
}

textarea::placeholder {
  color: var(--text-muted);
}

.console {
  flex: 1;
  overflow: auto;
  padding: 16px;
  background: var(--console-bg);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 13px;
  line-height: 1.7;
}

.console .line {
  padding: 2px 0;
  border-radius: 4px;
}

.console .log { color: var(--console-log); }
.console .err { color: var(--console-err); }
.console .sys { color: var(--console-sys); }
.console .help { 
  color: var(--console-help); 
  background: rgba(251, 191, 36, 0.1);
  padding: 8px 12px;
  margin: 8px 0;
  border-radius: 8px;
  border-left: 3px solid var(--console-help);
}
.console .help-title {
  font-weight: 600;
  margin-bottom: 4px;
}
.console .help-code {
  background: rgba(0,0,0,0.3);
  padding: 8px 12px;
  border-radius: 6px;
  margin-top: 8px;
  font-size: 12px;
  white-space: pre;
}

.prompt-wrap {
  display: none;
  padding: 12px 16px;
  background: var(--bg-elevated);
  border-top: 1px solid var(--border);
  gap: 8px;
  align-items: center;
  flex-shrink: 0;
}

.prompt-wrap.show {
  display: flex;
}

.prompt-wrap input {
  flex: 1;
  padding: 10px 14px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--text-primary);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 14px;
  outline: none;
  transition: border-color 0.15s ease;
}

.prompt-wrap input:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-glow);
}

.status {
  padding: 8px 16px;
  background: var(--bg);
  border-top: 1px solid var(--border);
  font-size: 12px;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.status-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: var(--text-muted);
}

.status-dot.running {
  background: var(--accent);
  animation: pulse 1s infinite;
}

.status-dot.error {
  background: var(--danger);
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

footer {
  padding: 12px 24px;
  background: var(--bg);
  border-top: 1px solid var(--border);
  text-align: center;
  font-size: 12px;
  color: var(--text-muted);
  flex-shrink: 0;
}

footer a {
  color: var(--accent);
  text-decoration: none;
}

.toast {
  position: fixed;
  bottom: 80px;
  left: 50%;
  transform: translateX(-50%) translateY(20px);
  background: var(--panel-bg);
  border: 1px solid var(--border);
  padding: 12px 20px;
  border-radius: 10px;
  font-size: 13px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  opacity: 0;
  pointer-events: none;
  transition: all 0.2s ease;
  z-index: 2000;
}

.toast.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

.kbd-hint {
  margin-left: auto;
  font-size: 11px;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  gap: 4px;
}

kbd {
  padding: 2px 6px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  font-family: 'Inter', sans-serif;
  font-size: 10px;
}

.help-modal, .blocks-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.8);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 3000;
  backdrop-filter: blur(4px);
}

.help-modal.show, .blocks-modal.show {
  display: flex;
}

.help-content {
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 16px;
  width: 90%;
  max-width: 600px;
  max-height: 80vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: 0 24px 64px rgba(0,0,0,0.5);
}

.help-header {
  padding: 20px 24px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.help-header h3 {
  font-size: 18px;
  font-weight: 600;
}

.help-body {
  padding: 24px;
  overflow-y: auto;
  font-size: 14px;
  line-height: 1.7;
}

.help-section {
  margin-bottom: 24px;
}

.help-section h4 {
  font-size: 13px;
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.help-section pre {
  background: var(--bg);
  padding: 16px;
  border-radius: 8px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 13px;
  overflow-x: auto;
  border: 1px solid var(--border);
}

/* Blocks Modal */
.blocks-content {
  background: #ffffff;
  border: 1px solid #ccc;
  border-radius: 8px;
  width: 95%;
  max-width: 900px;
  max-height: 90vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: 0 24px 64px rgba(0,0,0,0.3);
}

.blocks-header {
  padding: 12px 20px;
  background: #f5f5f5;
  border-bottom: 1px solid #ddd;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.blocks-header h3 {
  font-size: 16px;
  font-weight: 600;
  color: #333;
  display: flex;
  align-items: center;
  gap: 8px;
}

.blocks-header .close-btn {
  background: #e9ecef;
  border: 1px solid #ccc;
  color: #333;
  padding: 6px 12px;
  font-size: 12px;
}

.blocks-header .close-btn:hover {
  background: #ddd;
}

.blocks-body {
  padding: 20px;
  overflow-y: auto;
  background: #ffffff;
  min-height: 200px;
}

/* APCSP Block Styles - Matching Official Exam Format */
#APblocks, .block-container {
  font-family: monospace;
  font-size: 14px;
  color: #000;
}

.block-statement {
  display: block;
  margin: 1px 0;
}

/* bl - Rounded Rectangle Block (most statements) */
.bl, .block-expr {
  border: solid 1px black;
  border-radius: 5px;
  font-family: monospace;
  padding: 2px 5px;
  background-color: white;
  display: inline-block;
  margin-top: 1px;
}

/* val - Square Rectangle (arguments, parameters, expressions) */
.val, .block-val {
  border: solid 1px black;
  border-radius: 0px;
  margin: 1px;
  padding: 2px 3px;
  display: inline-block;
  background-color: white;
}

/* cond - Oval (conditions) */
.cond, .block-cond {
  border: solid 1px black;
  border-radius: 30px;
  padding: 1px 10px;
  display: inline-block;
  background-color: white;
}

/* Dark/Gray blocks for IF, REPEAT, PROCEDURE, FOR */
.dark, .block-control {
  background-color: #dddddd;
  border: solid 1px black;
  border-radius: 5px;
  padding: 5px;
  padding-top: 5px;
  margin: 1px 0;
  display: block;
}

.block-control-header {
  display: inline;
}

.block-control-body {
  display: block;
  margin-left: 16px;
  margin-top: 1px;
}

.block-procedure {
  background-color: #dddddd;
  border: solid 1px black;
  border-radius: 5px;
  padding: 5px;
  padding-top: 5px;
  margin: 1px 0;
  display: block;
}

.block-procedure-header {
  display: inline;
}

.block-procedure-body {
  display: block;
  margin-left: 16px;
  margin-top: 1px;
}

.block-keyword {
  font-weight: normal;
  font-family: monospace;
}

.block-arrow {
  font-family: monospace;
}

.block-list {
  border: solid 1px black;
  border-radius: 0px;
  padding: 2px 3px;
  display: inline-block;
  background-color: white;
}

.block-else {
  margin-top: 1px;
  font-family: monospace;
  display: block;
}

.blocks-error {
  background: #fff3f3;
  border: 1px solid #ffcdd2;
  border-radius: 5px;
  padding: 12px;
  color: #c62828;
  font-size: 14px;
}

@media (max-width: 768px) {
  main {
    grid-template-columns: 1fr;
    grid-template-rows: 1fr 1fr;
  }
  
  .resizer {
    width: 100%; 
    height: 12px;
    top: calc(50% - 6px);
    left: 0;
    cursor: row-resize;
  }
  
  .resizer::after {
    width: 48px;
    height: 4px;
  }
  
  .toolbar {
    flex-wrap: wrap;
  }
  
  .kbd-hint {
    display: none;
  }
}
</style>
</head>

<body>
<header>
  <div class="logo">
    <div class="logo-icon">C</div>
    <div class="logo-text"><span>CITRIN: </span>  TBA PSEUDOCODE CONSOLE <span> (v2.7)</span> </div>
  </div>

  <div class="header-actions">
<button class="ghost" id="themeBtn" title="Toggle Light/Dark Mode">
  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
</button>

    <button class="ghost" id="helpBtn" title="Syntax Reference">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="10"></circle>
        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
        <line x1="12" y1="17" x2="12.01" y2="17"></line>
      </svg>
      Help
    </button>
  </div>
</header>

<main>
  <div class="resizer" id="resizer"></div>
  
  <section class="panel">
    <div class="panel-header">
      <div class="dot"></div>
      <h2>Program Editor (INPUT)</h2>
    </div>
    <div class="toolbar">
      <div class="toolbar-group">
        <button class="primary" id="runBtn">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
            <polygon points="5 3 19 12 5 21 5 3"></polygon>
          </svg>
          Run
        </button>
        <button class="danger" id="stopBtn">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          </svg>
          Stop
        </button>
      </div>
      
      <div class="toolbar-divider"></div>
      
      <div class="toolbar-group">
        <button id="copyBtn" class="ghost">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
          Copy
        </button>
        <button id="blocksBtn" class="ghost">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="7" height="7" rx="1"></rect>
            <rect x="14" y="3" width="7" height="7" rx="1"></rect>
            <rect x="3" y="14" width="7" height="7" rx="1"></rect>
            <rect x="14" y="14" width="7" height="7" rx="1"></rect>
          </svg>
          Blocks
        </button>
      </div>
      
      <div class="toolbar-divider"></div>
      
      <div class="dropdown">
        <button class="dropdown-trigger ghost" id="samplesBtn">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path>
            <polyline points="14 2 14 8 20 8"></polyline>
          </svg>
          Examples
        </button>
        <div class="dropdown-menu" id="samplesMenu"></div>
      </div>
      
      <div class="kbd-hint">
        <kbd>Ctrl</kbd> + <kbd>Enter</kbd> to run
      </div>
    </div>
    <div class="editor-wrapper">
      <div class="line-numbers" id="lineNumbers"></div>
      <textarea id="editor" placeholder="Write your APCSP pseudocode here..." spellcheck="false"></textarea>
    </div>
  </section>

  <section class="panel">
    <div class="panel-header">
      <div class="dot"></div>
      <h2>Console (Output)</h2>
    </div>
    <div class="console" id="console"></div>
    <div class="prompt-wrap" id="promptWrap">
      <input id="promptInput" placeholder="Enter input‚Ä¶" />
      <button id="promptOk" class="primary">Submit</button>
      <button id="promptCancel">Cancel</button>
    </div>
    <div class="status" id="status">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Ready</span>
    </div>
  </section>
</main>

<footer>
  @Citrin ‚Ä¢ TechBoston Academy
</footer>

<div class="toast" id="toast"></div>

<div class="help-modal" id="helpModal">
  <div class="help-content">
    <div class="help-header">
      <h3>üìñ APCSP Syntax Reference</h3>
      <button class="ghost" id="closeHelp">‚úï</button>
    </div>
    <div class="help-body">
      <div class="help-section">
        <h4>Assignment, Display, and Input</h4>
        <pre>a ‚Üê expression
DISPLAY(expression)
INPUT()</pre>
      </div>
      <div class="help-section">
        <h4>Arithmetic Operators</h4>
        <pre>a + b    a - b    a * b    a / b
a MOD b</pre>
      </div>
      <div class="help-section">
        <h4>Relational and Boolean Operators</h4>
        <pre>a = b    a ‚â† b    a > b    a < b    a ‚â• b    a ‚â§ b
NOT condition
condition1 AND condition2
condition1 OR condition2</pre>
      </div>
      <div class="help-section">
        <h4>Selection</h4>
        <pre>IF(condition)
{
   &lt;block of statements&gt;
}

IF(condition)
{
   &lt;first block of statements&gt;
}
ELSE
{
   &lt;second block of statements&gt;
}</pre>
      </div>
      <div class="help-section">
        <h4>Iteration</h4>
        <pre>REPEAT n TIMES
{
   &lt;block of statements&gt;
}

REPEAT UNTIL(condition)
{
   &lt;block of statements&gt;
}</pre>
      </div>
      <div class="help-section">
        <h4>List Operations</h4>
        <pre>aList ‚Üê [value1, value2, value3]
aList[i]
x ‚Üê aList[i]
aList[i] ‚Üê x
INSERT(aList, i, value)
APPEND(aList, value)
REMOVE(aList, i)
LENGTH(aList)

FOR EACH item IN aList
{
   &lt;block of statements&gt;
}</pre>
      </div>
      <div class="help-section">
        <h4>String Operations</h4>
        <pre>CONTAINS(text, substring)    # Returns true/false
text[i]                      # Get character at index i (1-indexed)
text[start, end]             # Get substring from start to end (1-indexed, inclusive)
LENGTH(text)                 # Returns string length

Example:
text ‚Üê "HELLO WORLD"
DISPLAY(text[1])             # Displays "H"
DISPLAY(SUBSTRING(text, 1, 5))  # Displays "HELLO"
IF(CONTAINS(text, "WORLD"))
{
   DISPLAY("Found it!")
}</pre>
      </div>
      <div class="help-section">
        <h4>Procedures</h4>
        <pre>PROCEDURE procName(parameter1, parameter2, ...)
{
   &lt;block of statements&gt;
}

PROCEDURE procName(parameter1, parameter2, ...)
{
   &lt;block of statements&gt;
   RETURN(expression)
}</pre>
      </div>
      <div class="help-section">
        <h4>Built-in Functions</h4>
        <pre>RANDOM(a, b)
LENGTH(aList)
CONTAINS(text, substring)
SUBSTRING(text, start, end)</pre>
      </div>
    </div>
  </div>
</div>

<div class="blocks-modal" id="blocksModal">
  <div class="blocks-content">
    <div class="blocks-header">
      <h3>
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="7" height="7" rx="1"></rect>
          <rect x="14" y="3" width="7" height="7" rx="1"></rect>
          <rect x="3" y="14" width="7" height="7" rx="1"></rect>
          <rect x="14" y="14" width="7" height="7" rx="1"></rect>
        </svg>
        APCSP Blocks View
      </h3>
      <button class="close-btn" id="closeBlocks">‚úï Close</button>
    </div>
    <div class="blocks-body" id="blocksBody"></div>
  </div>
</div>

<script>
window.addEventListener("DOMContentLoaded", () => {
  const $ = s => document.querySelector(s);
  const $$ = s => document.querySelectorAll(s);

  const logEl = $("#console"), statusText = $("#statusText"), statusDot = $("#statusDot"), editor = $("#editor");
  const lineNumbers = $("#lineNumbers");
  const promptWrap = $("#promptWrap"), promptInput = $("#promptInput");
  const promptOk = $("#promptOk"), promptCancel = $("#promptCancel");
  const toast = $("#toast");
  const helpModal = $("#helpModal");
  const blocksModal = $("#blocksModal");
  const blocksBody = $("#blocksBody");
  
  let halted = false, inputResolve = null, inputReject = null;

$("#themeBtn").onclick = () => document.body.classList.toggle("light-mode");

  function showToast(msg) {
    toast.textContent = msg;
    toast.classList.add("show");
    setTimeout(() => toast.classList.remove("show"), 2000);
  }

  function updateLineNumbers() {
    const lines = editor.value.split('\n').length;
    lineNumbers.innerHTML = Array.from({length: lines}, (_, i) => i + 1).join('\n');
  }

  editor.addEventListener('input', updateLineNumbers);
  editor.addEventListener('scroll', () => {
    lineNumbers.scrollTop = editor.scrollTop;
  });

  function formatValue(val) {
    if (val === null || val === undefined) {
      return "undefined";
    }
    if (Array.isArray(val)) {
      return "[" + val.map(v => {
        if (typeof v === "string") return '"' + v + '"';
        if (Array.isArray(v)) return formatValue(v);
        return String(v);
      }).join(", ") + "]";
    }
    return String(val);
  }

  const out = (m, c = "log") => {
    const d = document.createElement("div");
    d.className = "line " + c;
    if (typeof m === 'object' && m !== null && m.html) {
      d.innerHTML = m.html;
    } else {
      d.textContent = formatValue(m);
    }
    logEl.appendChild(d);
    logEl.scrollTop = logEl.scrollHeight;
  };
  
  const log = m => out(m, "log");
  const err = m => out(m, "err");
  const sys = m => out(m, "sys");
  const help = (title, description, example) => {
    out({
      html: `<div class="help-title">üí° ${title}</div>${description}<div class="help-code">${example}</div>`
    }, "help");
  };

  const setStatus = (s, state = "idle") => {
    statusText.textContent = s;
    statusDot.className = "status-dot";
    if (state === "running") statusDot.classList.add("running");
    if (state === "error") statusDot.classList.add("error");
  };

  const syntaxHelp = {
    procedure: { title: "PROCEDURE Syntax Error", desc: "Procedures must follow this exact format:", example: `PROCEDURE procName(parameter1, parameter2)\n{\n   <block of statements>\n   RETURN(expression)\n}` },
    if: { title: "IF Statement Syntax Error", desc: "IF statements require parentheses around the condition:", example: `IF(condition)\n{\n   <block of statements>\n}\nELSE\n{\n   <block of statements>\n}` },
    nestedIf: { title: "Nested IF Syntax", desc: "You can nest IF statements inside each other:", example: `IF(condition1)\n{\n   IF(condition2)\n   {\n      <statements>\n   }\n}` },
    repeatTimes: { title: "REPEAT TIMES Syntax Error", desc: "The REPEAT n TIMES loop format:", example: `REPEAT n TIMES\n{\n   <block of statements>\n}` },
    repeatUntil: { title: "REPEAT UNTIL Syntax Error", desc: "The REPEAT UNTIL loop format:", example: `REPEAT UNTIL(condition)\n{\n   <block of statements>\n}` },
    forEach: { title: "FOR EACH Syntax Error", desc: "The FOR EACH loop format (APCSP compliant):", example: `FOR EACH item IN aList\n{\n   DISPLAY(item)\n}` },
    assignment: { title: "Assignment Syntax Error", desc: "Use the arrow operator ‚Üê for assignment:", example: `variable ‚Üê value\nvariable ‚Üê expression\naList[i] ‚Üê value` },
    display: { title: "DISPLAY Syntax Error", desc: "DISPLAY requires parentheses:", example: `DISPLAY(expression)\nDISPLAY("Hello World")\nDISPLAY(variable)` },
    list: { title: "List Syntax Error", desc: "Lists use 1-based indexing:", example: `aList ‚Üê [value1, value2, value3]\naList[1]\naList[i] ‚Üê value\nLENGTH(aList)\nAPPEND(aList, value)\nINSERT(aList, i, value)\nREMOVE(aList, i)` },
    return: { title: "RETURN Syntax Error", desc: "RETURN must be inside a procedure:", example: `PROCEDURE procName(param)\n{\n   RETURN(expression)\n}` },
    block: { title: "Block Syntax Error", desc: "Code blocks must use curly braces:", example: `IF(condition)\n{\n   <statements here>\n}` },
    brace: { title: "Brace Mismatch Error", desc: "Every opening { must have a matching closing }:", example: `PROCEDURE example()\n{\n   IF(condition)\n   {\n      <nested code>\n   }\n}` },
    boolean: { title: "Boolean Expression Error", desc: "Boolean expressions evaluate to true or false:", example: `a = b\na ‚â† b\na > b    a < b    a ‚â• b    a ‚â§ b\nNOT condition\ncond1 AND cond2\ncond1 OR cond2` },
    random: { title: "RANDOM Syntax Error", desc: "RANDOM generates a random integer from a to b inclusive:", example: `RANDOM(1, 10)` },
    mod: { title: "MOD Operator Error", desc: "MOD returns the remainder of division:", example: `17 MOD 5\nx MOD 2 = 0` },
    input: { title: "INPUT Syntax Error", desc: "INPUT accepts a value from the user:", example: `name ‚Üê INPUT()\nDISPLAY("Hello " + name)` },
    undefined: { title: "Undefined Variable Error", desc: "Make sure variables are assigned before use:", example: `x ‚Üê 10\nDISPLAY(x)` },
    length: { title: "LENGTH Syntax Error", desc: "LENGTH returns the number of elements in a list:", example: `aList ‚Üê [1, 2, 3]\nlen ‚Üê LENGTH(aList)` },
    append: { title: "APPEND Syntax Error", desc: "APPEND adds a value to the end of a list:", example: `aList ‚Üê [1, 2]\nAPPEND(aList, 3)` },
    insert: { title: "INSERT Syntax Error", desc: "INSERT adds a value at a specific index:", example: `aList ‚Üê [1, 3]\nINSERT(aList, 2, 2)` },
    remove: { title: "REMOVE Syntax Error", desc: "REMOVE removes a value at a specific index:", example: `aList ‚Üê [1, 2, 3]\nREMOVE(aList, 2)` },
    contains: { title: "CONTAINS Syntax", desc: "CONTAINS checks if a substring exists in text:", example: `text ‚Üê "WINNER WINNER"\nIF(CONTAINS(text, "WIN"))\n{\n   DISPLAY("Found!")\n}` },
    substring: { title: "SUBSTRING Syntax", desc: "SUBSTRING extracts part of a string (1-indexed, inclusive):", example: `text ‚Üê "HELLO WORLD"\nDISPLAY(SUBSTRING(text, 1, 5))  # "HELLO"\nDISPLAY(SUBSTRING(text, 7, 11)) # "WORLD"\nDISPLAY(text[1])  # "H" (single character)` }
  };

  function showSyntaxHelp(type) {
    const h = syntaxHelp[type];
    if (h) help(h.title, h.desc, h.example);
  }

  function detectAndShowHelp(errorMsg, line) {
    const lowerErr = errorMsg.toLowerCase();
    const lowerLine = line ? line.toLowerCase() : "";
    
    if (lowerErr.includes("undefined") || lowerErr.includes("is not defined")) showSyntaxHelp("undefined");
    else if (lowerErr.includes("unclosed") || lowerErr.includes("missing closing") || lowerErr.includes("unexpected }") || lowerErr.includes("unexpected {") || lowerErr.includes("no matching")) showSyntaxHelp("brace");
    else if (lowerErr.includes("procedure") || lowerLine.startsWith("procedure")) showSyntaxHelp("procedure");
    else if (lowerErr.includes("nested") && lowerErr.includes("if")) showSyntaxHelp("nestedIf");
    else if (lowerErr.includes("if") || lowerLine.startsWith("if")) showSyntaxHelp("if");
    else if (lowerErr.includes("repeat") && lowerErr.includes("times")) showSyntaxHelp("repeatTimes");
    else if (lowerErr.includes("repeat") && lowerErr.includes("until")) showSyntaxHelp("repeatUntil");
    else if (lowerErr.includes("for each") || lowerLine.startsWith("for each")) showSyntaxHelp("forEach");
    else if (lowerErr.includes("return")) showSyntaxHelp("return");
    else if (lowerErr.includes("display")) showSyntaxHelp("display");
    else if (lowerErr.includes("random")) showSyntaxHelp("random");
    else if (lowerErr.includes("mod")) showSyntaxHelp("mod");
    else if (lowerErr.includes("input")) showSyntaxHelp("input");
    else if (lowerErr.includes("length")) showSyntaxHelp("length");
    else if (lowerErr.includes("append")) showSyntaxHelp("append");
    else if (lowerErr.includes("insert")) showSyntaxHelp("insert");
    else if (lowerErr.includes("remove")) showSyntaxHelp("remove");
    else if (lowerErr.includes("contains")) showSyntaxHelp("contains");
    else if (lowerErr.includes("substring") || lowerErr.includes("slice")) showSyntaxHelp("substring");
    else if (lowerErr.includes("list") || lowerErr.includes("index")) showSyntaxHelp("list");
    else if (lowerErr.includes("boolean") || lowerErr.includes("and") || lowerErr.includes("or") || lowerErr.includes("not")) showSyntaxHelp("boolean");
    else if (lowerErr.includes("assignment") || lowerErr.includes("‚Üê") || lowerErr.includes("<-")) showSyntaxHelp("assignment");
    else if (lowerErr.includes("{") || lowerErr.includes("}") || lowerErr.includes("block") || lowerErr.includes("followed by")) showSyntaxHelp("block");
  }

  function showPrompt(label) {
    promptInput.value = "";
    promptInput.placeholder = label || "Input";
    promptWrap.classList.add("show");
    promptInput.focus();
    return new Promise((res, rej) => { inputResolve = res; inputReject = rej; });
  }
  
  function hidePrompt() { promptWrap.classList.remove("show"); }
  
  promptOk.onclick = () => {
    if (inputResolve) {
      inputResolve(promptInput.value);
      hidePrompt();
      inputResolve = null;
      inputReject = null;
    }
  };
  
  promptCancel.onclick = () => {
    if (inputReject) {
      inputReject(new Error("Input cancelled"));
      hidePrompt();
      inputResolve = null;
      inputReject = null;
    }
  };
  
  promptInput.addEventListener("keydown", e => {
    if (e.key === "Enter") promptOk.click();
    if (e.key === "Escape") promptCancel.click();
  });

  function preprocess(src) {
    return src.split(/\r?\n/).map((raw, idx) => {
      const s = raw.replace(/#.*$/, "").replace(/\/\/.*$/, "").replace(/\t/g, "    ").trim();
      return { idx, raw, s };
    });
  }

  function validateBraces(lines) {
    let depth = 0;
    let expectingOpen = false;
    let lastConstruct = null;
    let lastConstructLine = 0;
    
    for (let i = 0; i < lines.length; i++) {
      const { s, idx } = lines[i];
      if (!s) continue;
      
      if (/^(PROCEDURE|IF|ELSE|REPEAT|FOR)\b/i.test(s) && !s.includes("{")) {
        if (expectingOpen) throw `${lastConstruct} at line ${lastConstructLine} must be followed by { but found "${s}" at line ${idx + 1}`;
        expectingOpen = true;
        lastConstruct = s.match(/^(\w+)/i)[1].toUpperCase();
        lastConstructLine = idx + 1;
        continue;
      }
      
      if (s === "{") {
        if (!expectingOpen && depth === 0) {
          let foundConstruct = false;
          for (let j = i - 1; j >= 0; j--) {
            if (lines[j].s) {
              if (/^(PROCEDURE|IF|ELSE|REPEAT|FOR)\b/i.test(lines[j].s)) foundConstruct = true;
              break;
            }
          }
          if (!foundConstruct) throw `Unexpected { at line ${idx + 1} - no matching control structure`;
        }
        expectingOpen = false;
        depth++;
      } else if (s === "}") {
        if (expectingOpen) throw `${lastConstruct} at line ${lastConstructLine} must be followed by { but found } at line ${idx + 1}`;
        depth--;
        if (depth < 0) throw `Unexpected } at line ${idx + 1} - no matching opening brace`;
      } else if (expectingOpen) {
        throw `${lastConstruct} at line ${lastConstructLine} must be followed by { but found "${s}" at line ${idx + 1}`;
      }
    }
    
    if (depth > 0) throw `Missing closing } - ${depth} unclosed block(s). Check that all IF, ELSE, REPEAT, FOR, and PROCEDURE blocks are properly closed`;
    if (expectingOpen) throw `${lastConstruct} at line ${lastConstructLine} must be followed by {`;
  }

  function parseProcedures(lines) {
    const procs = {};
    let i = 0;
    while (i < lines.length) {
      const t = lines[i].s;
      if (/^PROCEDURE\b/i.test(t)) {
        const m = t.match(/^PROCEDURE\s+([A-Za-z_]\w*)\s*\(([^)]*)\)/i);
        if (!m) throw `Bad PROCEDURE syntax at line ${lines[i].idx + 1}. Format: PROCEDURE procName(param1, param2)`;
        const name = m[1];
        const params = m[2].trim() ? m[2].split(",").map(s => s.trim()) : [];

        i++;
        if (i >= lines.length || lines[i].s !== "{") throw `PROCEDURE ${name} at line ${lines[i - 1].idx + 1} must be followed by {`;

        const bodyStart = i + 1;
        let depth = 1;
        i++;
        while (i < lines.length && depth > 0) {
          if (lines[i].s === "{") depth++;
          else if (lines[i].s === "}") depth--;
          i++;
        }

        if (depth !== 0) throw `Unclosed PROCEDURE ${name}`;

        const bodyEnd = i - 1;
        procs[name] = { name, params, start: bodyStart, end: bodyEnd };
      } else {
        i++;
      }
    }
    return procs;
  }

  let LINES = [], PROCS = null, ENV = null;

  function makeEval(env, procs) {
    const safe = /^[\w\s+\-*/%().,<>!="""'\[\]‚â§‚â•‚â†?:&|]+$/u;

    function rewrite(expr) {
      let result = expr
        .replace(/[""]/g, '"')
        .replace(/‚â§/g, "<=").replace(/‚â•/g, ">=").replace(/‚â†/g, "!=")
        .replace(/\bAND\b/gi, "&&").replace(/\bOR\b/gi, "||").replace(/\bNOT\b/gi, "!")
        .replace(/\bMOD\b/gi, "%")
        .replace(/([A-Za-z_]\w*)\s*\[\s*([^\]]+)\s*\]/g, "IDX($1,($2))");

      result = result.replace(/([^<>!=])=([^=])/g, '$1==$2');

      for (const procName in procs) {
        const regex = new RegExp(`\\b${procName}\\s*\\(`, 'g');
        result = result.replace(regex, `await ${procName}(`);
      }

      return result;
    }

    async function callProc(name, args, callerEnv) {
      const def = procs[name];
      if (!def) throw `Unknown procedure '${name}'`;
      const local = Object.create(callerEnv);
      for (let i = 0; i < def.params.length; i++) {
        local[def.params[i]] = i < args.length ? args[i] : undefined;
      }
      const result = await execRange(def.start, def.end, local, true);
      return result !== undefined && result !== null ? result : null;
    }

    return async function evalExpr(expr) {
      const e = rewrite(expr);
      if (!safe.test(e)) throw `Expression contains unsupported characters: ${e}`;

      const scope = {
        Math,
        RANDOM: (a, b) => {
          if (a === undefined || b === undefined) throw "RANDOM requires two arguments: RANDOM(a, b)";
          return Math.floor(Math.random() * (b - a + 1)) + a;
        },
        INPUT: async () => {
          const val = await showPrompt("Input");
          return isNaN(val) || val === "" ? val : Number(val);
        },
        APPEND: (L, v) => {
          if (!Array.isArray(L)) throw "APPEND: first argument must be a list";
          if (v === undefined) throw "APPEND requires two arguments: APPEND(aList, value)";
          L.push(v);
        },
        INSERT: (L, i, v) => {
          if (!Array.isArray(L)) throw "INSERT: first argument must be a list";
          if (i === undefined || v === undefined) throw "INSERT requires three arguments: INSERT(aList, i, value)";
          if (i < 1 || i > L.length + 1) throw `INSERT: invalid index ${i}. Must be between 1 and ${L.length + 1}`;
          L.splice(i - 1, 0, v);
        },
        REMOVE: (L, i) => {
          if (!Array.isArray(L)) throw "REMOVE: first argument must be a list";
          if (i === undefined) throw "REMOVE requires two arguments: REMOVE(aList, i)";
          if (i < 1 || i > L.length) throw `REMOVE: invalid index ${i}. List length is ${L.length}`;
          L.splice(i - 1, 1);
        },
        LENGTH: L => {
          if (L == null) throw "LENGTH: argument is undefined. Make sure the list or string exists.";
          if (typeof L === 'string') return L.length;
          if (!Array.isArray(L)) throw "LENGTH: argument must be a list or string";
          return L.length;
        },
        IDX: (L, i) => {
          if (L == null) throw "Access error: variable is undefined. Make sure it exists.";
          // Handle strings as character arrays (1-indexed)
          if (typeof L === 'string') {
            if (i < 1 || i > L.length) throw `String index out of bounds: index ${i}, but string length is ${L.length}. Remember: strings are 1-indexed.`;
            return L[i - 1];
          }
          if (!Array.isArray(L)) throw "Access error: variable is not a list or string";
          if (i < 1 || i > L.length) throw `List index out of bounds: index ${i}, but list length is ${L.length}. Remember: lists are 1-indexed.`;
          return L[i - 1];
        },
        CONTAINS: (text, substring) => {
          if (text === undefined || substring === undefined) throw "CONTAINS requires two arguments: CONTAINS(text, substring)";
          const textStr = String(text);
          const subStr = String(substring);
          return textStr.includes(subStr);
        },
        SUBSTRING: (text, start, end) => {
          if (text === undefined) throw "SUBSTRING: text is undefined";
          if (start === undefined || end === undefined) throw "SUBSTRING requires three arguments: SUBSTRING(text, start, end)";
          const textStr = String(text);
          if (start < 1 || end < 1 || start > textStr.length || end > textStr.length) {
            throw `SUBSTRING index out of bounds: [${start}, ${end}], string length is ${textStr.length}. Remember: strings are 1-indexed.`;
          }
          if (start > end) throw `SUBSTRING: start index ${start} cannot be greater than end index ${end}`;
          return textStr.substring(start - 1, end);
        },
        CONCAT: (...args) => {
          return args.map(a => String(a)).join('');
        },
        LOWERCASE: (text) => {
          if (text === undefined) throw "LOWERCASE: argument is undefined";
          return String(text).toLowerCase();
        },
        UPPERCASE: (text) => {
          if (text === undefined) throw "UPPERCASE: argument is undefined";
          return String(text).toUpperCase();
        }
      };

      let currentEnv = env;
      while (currentEnv) {
        for (const key of Object.getOwnPropertyNames(currentEnv)) {
          if (!scope.hasOwnProperty(key)) scope[key] = currentEnv[key];
        }
        const proto = Object.getPrototypeOf(currentEnv);
        if (!proto || proto === Object.prototype) break;
        currentEnv = proto;
      }

      for (const name in procs) {
        if (!scope.hasOwnProperty(name)) {
          scope[name] = async (...args) => {
            const result = await callProc(name, args, env);
            return result;
          };
        }
      }

      const scopeKeys = Object.keys(scope);
      const scopeValues = Object.values(scope);

      try {
        const asyncFn = new Function(...scopeKeys, `return (async function() { return (${e}); })();`);
        return await asyncFn(...scopeValues);
      } catch (err) {
        if (err.message && err.message.includes("is not defined")) {
          const varMatch = err.message.match(/(\w+) is not defined/);
          if (varMatch) throw `Variable '${varMatch[1]}' is not defined. Make sure to assign it a value first with: ${varMatch[1]} ‚Üê value`;
        }
        throw err.message || err;
      }
    };
  }

  async function execRange(start, end, env, insideProc = false) {
    const evalExpr = makeEval(env, PROCS);
    let i = start;

    while (i < end) {
      if (halted) return null;
      const { s, idx } = LINES[i];

      if (!s || s === "{" || s === "}") { i++; continue; }

      if (!insideProc && /^PROCEDURE\b/i.test(s)) {
        const m = s.match(/^PROCEDURE\s+([A-Za-z_]\w*)/i);
        const name = m[1];
        const def = PROCS[name];
        i = def.end + 1;
        continue;
      }

      if (/^RETURN\b/i.test(s)) {
        if (!insideProc) throw `RETURN outside procedure at line ${idx + 1}. RETURN can only be used inside a PROCEDURE.`;
        const m = s.match(/^RETURN\s*\((.*)\)/i);
        if (!m) throw `Invalid RETURN syntax at line ${idx + 1}. Use: RETURN(expression)`;
        const returnVal = m[1].trim() ? await evalExpr(m[1]) : null;
        return returnVal;
      }

      if (/^DISPLAY\s*\(/i.test(s)) {
        const m = s.match(/^DISPLAY\s*\((.*)\)/i);
        if (!m) throw `Invalid DISPLAY syntax at line ${idx + 1}. Use: DISPLAY(expression)`;
        const val = await evalExpr(m[1]);
        log(val);
        i++;
        continue;
      }

      if (/^[A-Za-z_]\w*\s*(‚Üê|<-)\s*(.*)$/.test(s)) {
        const m = s.match(/^([A-Za-z_]\w*)\s*(?:‚Üê|<-)\s*(.*)$/);
        const varName = m[1];
        const expr = m[2];
        if (!expr.trim()) throw `Missing value in assignment at line ${idx + 1}. Use: ${varName} ‚Üê value`;
        const val = await evalExpr(expr);

        let targetEnv = env;
        let found = false;
        while (targetEnv) {
          if (Object.prototype.hasOwnProperty.call(targetEnv, varName)) {
            targetEnv[varName] = val;
            found = true;
            break;
          }
          const proto = Object.getPrototypeOf(targetEnv);
          if (!proto || proto === Object.prototype) break;
          targetEnv = proto;
        }

        if (!found) env[varName] = val;
        i++;
        continue;
      }

      if (/^[A-Za-z_]\w*\s*\[\s*.*\s*\]\s*(‚Üê|<-)\s*(.*)$/.test(s)) {
        const m = s.match(/^([A-Za-z_]\w*)\s*\[\s*(.*?)\s*\]\s*(?:‚Üê|<-)\s*(.*)$/);
        const listName = m[1];
        const indexExpr = m[2];
        const valueExpr = m[3];

        const list = await evalExpr(listName);
        const index = await evalExpr(indexExpr);
        const value = await evalExpr(valueExpr);

        if (!Array.isArray(list)) throw `${listName} is not a list at line ${idx + 1}`;
        if (index < 1 || index > list.length) throw `Index ${index} out of bounds at line ${idx + 1}. List length is ${list.length}. Remember: lists are 1-indexed.`;

        list[index - 1] = value;
        i++;
        continue;
      }

      if (/^IF\s*\(/i.test(s)) {
        const m = s.match(/^IF\s*\((.*)\)/i);
        if (!m) throw `Invalid IF syntax at line ${idx + 1}. Use: IF(condition)`;
        const cond = await evalExpr(m[1]);

        i++;
        if (i >= end || LINES[i].s !== "{") throw `IF at line ${idx + 1} must be followed by {`;

        const blockStart = i + 1;
        let depth = 1;
        i++;
        while (i < end && depth > 0) {
          if (LINES[i].s === "{") depth++;
          else if (LINES[i].s === "}") depth--;
          i++;
        }
        const blockEnd = i - 1;

        if (cond) {
          const result = await execRange(blockStart, blockEnd, env, insideProc);
          if (insideProc && result !== undefined && result !== null) return result;

          if (i < end && /^ELSE\b/i.test(LINES[i].s)) {
            i++;
            if (i < end && LINES[i].s === "{") {
              depth = 1;
              i++;
              while (i < end && depth > 0) {
                if (LINES[i].s === "{") depth++;
                else if (LINES[i].s === "}") depth--;
                i++;
              }
            }
          }
        } else {
          if (i < end && /^ELSE\b/i.test(LINES[i].s)) {
            i++;
            if (i >= end || LINES[i].s !== "{") throw `ELSE at line ${LINES[i - 1].idx + 1} must be followed by {`;

            const elseStart = i + 1;
            depth = 1;
            i++;
            while (i < end && depth > 0) {
              if (LINES[i].s === "{") depth++;
              else if (LINES[i].s === "}") depth--;
              i++;
            }
            const elseEnd = i - 1;

            const result = await execRange(elseStart, elseEnd, env, insideProc);
            if (insideProc && result !== undefined && result !== null) return result;
          }
        }
        continue;
      }

      if (/^REPEAT\s+(\d+|\(.*?\)|\S+)\s+TIMES/i.test(s)) {
        const m = s.match(/^REPEAT\s+(.*?)\s+TIMES/i);
        const countExpr = m[1];
        const n = await evalExpr(countExpr);

        if (typeof n !== 'number' || n < 0) throw `REPEAT TIMES at line ${idx + 1}: count must be a non-negative number, got ${n}`;

        i++;
        if (i >= end || LINES[i].s !== "{") throw `REPEAT TIMES at line ${idx + 1} must be followed by {`;

        const blockStart = i + 1;
        let depth = 1;
        i++;
        while (i < end && depth > 0) {
          if (LINES[i].s === "{") depth++;
          else if (LINES[i].s === "}") depth--;
          i++;
        }
        const blockEnd = i - 1;

        for (let rep = 0; rep < n; rep++) {
          if (halted) return null;
          const result = await execRange(blockStart, blockEnd, env, insideProc);
          if (result !== undefined && result !== null && insideProc) return result;
        }
        continue;
      }

      if (/^REPEAT\s+UNTIL\s*\(/i.test(s)) {
        const m = s.match(/^REPEAT\s+UNTIL\s*\((.*)\)/i);
        if (!m) throw `Invalid REPEAT UNTIL syntax at line ${idx + 1}. Use: REPEAT UNTIL(condition)`;
        const condExpr = m[1];

        i++;
        if (i >= end || LINES[i].s !== "{") throw `REPEAT UNTIL at line ${idx + 1} must be followed by {`;

        const blockStart = i + 1;
        let depth = 1;
        i++;
        while (i < end && depth > 0) {
          if (LINES[i].s === "{") depth++;
          else if (LINES[i].s === "}") depth--;
          i++;
        }
        const blockEnd = i - 1;

        while (true) {
          if (halted) return null;
          const result = await execRange(blockStart, blockEnd, env, insideProc);
          if (result !== undefined && result !== null && insideProc) return result;

          const cond = await evalExpr(condExpr);
          if (cond) break;
        }
        continue;
      }

      if (/^FOR\s+EACH\s+/i.test(s)) {
        const m = s.match(/^FOR\s+EACH\s+(\w+)\s+IN\s+(.+)/i);
        if (!m) throw `Invalid FOR EACH syntax at line ${idx + 1}. Use: FOR EACH item IN aList`;
        const itemVar = m[1];
        const listExpr = m[2];

        const list = await evalExpr(listExpr);
        if (!Array.isArray(list) && typeof list !== 'string') throw `FOR EACH at line ${idx + 1}: ${listExpr} is not a list or string`;

        i++;
        if (i >= end || LINES[i].s !== "{") throw `FOR EACH at line ${idx + 1} must be followed by {`;

        const blockStart = i + 1;
        let depth = 1;
        i++;
        while (i < end && depth > 0) {
          if (LINES[i].s === "{") depth++;
          else if (LINES[i].s === "}") depth--;
          i++;
        }
        const blockEnd = i - 1;

        // Support iterating over strings as character arrays
        const iterable = typeof list === 'string' ? list.split('') : list;
        for (const item of iterable) {
          if (halted) return null;
          env[itemVar] = item;
          const result = await execRange(blockStart, blockEnd, env, insideProc);
          if (result !== undefined && result !== null && insideProc) return result;
        }

        delete env[itemVar];
        continue;
      }

      if (/^(APPEND|INSERT|REMOVE)\s*\(/i.test(s)) {
        await evalExpr(s);
        i++;
        continue;
      }

      if (/^[A-Za-z_]\w*\s*\(/i.test(s)) {
        const m = s.match(/^([A-Za-z_]\w*)/);
        if (m && PROCS[m[1]]) {
          await evalExpr(s);
          i++;
          continue;
        }
      }

      throw `Unknown statement at line ${idx + 1}: "${s}"`;
    }
    return null;
  }

  async function run(src) {
    halted = false;
    logEl.innerHTML = "";
    setStatus("Parsing‚Ä¶", "running");
    
    try {
      LINES = preprocess(src);
      validateBraces(LINES);
      PROCS = parseProcedures(LINES);
      ENV = Object.create(null);
    } catch (e) {
      err("Parse Error: " + e);
      detectAndShowHelp(String(e), "");
      setStatus("Parse Error", "error");
      return;
    }

    setStatus("Running‚Ä¶", "running");
    try {
      await execRange(0, LINES.length, ENV, false);
      setStatus("Finished");
      sys("‚úì Program completed successfully");
    } catch (e) {
      err("Runtime Error: " + e);
      const lineMatch = String(e).match(/line\s*(\d+)/i);
      const lineNum = lineMatch ? parseInt(lineMatch[1]) - 1 : -1;
      const lineContent = lineNum >= 0 && LINES[lineNum] ? LINES[lineNum].s : "";
      detectAndShowHelp(String(e), lineContent);
      setStatus("Error", "error");
    }
  }

  // ===== BLOCKS RENDERER - Authentic APCSP Style =====
  function escapeHtml(text) {
    return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  }

  function renderVal(expr) {
    return `<span class="block-val">${escapeHtml(expr)}</span>`;
  }

  function renderCond(expr) {
    return `<span class="block-cond">${escapeHtml(expr)}</span>`;
  }

  function renderBlock(content, isDark = false) {
    return `<span class="block-expr${isDark ? ' dark' : ''}">${content}</span>`;
  }

  function renderExpression(expr) {
    expr = expr.trim();
    if (!expr) return '';
    
    // Handle string literals - use val style (square)
    if (/^["'"].*["'"]$/.test(expr)) {
      return renderVal(expr);
    }
    
    // Handle lists - use val style (square)
    if (/^\[.*\]$/.test(expr)) {
      return renderVal(expr);
    }
    
    // Handle function calls - rounded block with val inside
    const funcMatch = expr.match(/^([A-Z_]+)\s*\((.*)\)$/i);
    if (funcMatch) {
      const funcName = funcMatch[1].toUpperCase();
      const args = funcMatch[2].trim();
      if (args) {
        return renderBlock(`${funcName} ${renderVal(args)}`);
      }
      return renderBlock(funcName);
    }
    
    // Handle list indexing - listName[index]
    const indexMatch = expr.match(/^([A-Za-z_]\w*)\s*\[\s*(.+)\s*\]$/);
    if (indexMatch) {
      return renderBlock(`${escapeHtml(indexMatch[1])}${renderVal(indexMatch[2])}`);
    }
    
    // Simple variable or number
    return escapeHtml(expr);
  }

  function parseBlocksAST(lines, start, end) {
    const blocks = [];
    let i = start;
    
    while (i < end) {
      const { s, idx } = lines[i];
      
      if (!s || s === "{" || s === "}") {
        i++;
        continue;
      }
      
      // PROCEDURE
      if (/^PROCEDURE\b/i.test(s)) {
        const m = s.match(/^PROCEDURE\s+([A-Za-z_]\w*)\s*\(([^)]*)\)/i);
        if (m) {
          const name = m[1];
          const params = m[2];
          i++;
          if (i < end && lines[i].s === "{") {
            const bodyStart = i + 1;
            let depth = 1;
            i++;
            while (i < end && depth > 0) {
              if (lines[i].s === "{") depth++;
              else if (lines[i].s === "}") depth--;
              i++;
            }
            const bodyEnd = i - 1;
            blocks.push({
              type: 'procedure',
              name,
              params,
              body: parseBlocksAST(lines, bodyStart, bodyEnd)
            });
          }
        } else {
          i++;
        }
        continue;
      }
      
      // IF
      if (/^IF\s*\(/i.test(s)) {
        const m = s.match(/^IF\s*\((.*)\)/i);
        if (m) {
          const condition = m[1];
          i++;
          let ifBody = [];
          let elseBody = null;
          
          if (i < end && lines[i].s === "{") {
            const bodyStart = i + 1;
            let depth = 1;
            i++;
            while (i < end && depth > 0) {
              if (lines[i].s === "{") depth++;
              else if (lines[i].s === "}") depth--;
              i++;
            }
            const bodyEnd = i - 1;
            ifBody = parseBlocksAST(lines, bodyStart, bodyEnd);
          }
          
          // Check for ELSE
          if (i < end && /^ELSE\b/i.test(lines[i].s)) {
            i++;
            if (i < end && lines[i].s === "{") {
              const elseStart = i + 1;
              let depth = 1;
              i++;
              while (i < end && depth > 0) {
                if (lines[i].s === "{") depth++;
                else if (lines[i].s === "}") depth--;
                i++;
              }
              const elseEnd = i - 1;
              elseBody = parseBlocksAST(lines, elseStart, elseEnd);
            }
          }
          
          blocks.push({
            type: 'if',
            condition,
            body: ifBody,
            elseBody
          });
        } else {
          i++;
        }
        continue;
      }
      
      // REPEAT n TIMES
      if (/^REPEAT\s+.+\s+TIMES/i.test(s)) {
        const m = s.match(/^REPEAT\s+(.*?)\s+TIMES/i);
        if (m) {
          const count = m[1];
          i++;
          if (i < end && lines[i].s === "{") {
            const bodyStart = i + 1;
            let depth = 1;
            i++;
            while (i < end && depth > 0) {
              if (lines[i].s === "{") depth++;
              else if (lines[i].s === "}") depth--;
              i++;
            }
            const bodyEnd = i - 1;
            blocks.push({
              type: 'repeat-times',
              count,
              body: parseBlocksAST(lines, bodyStart, bodyEnd)
            });
          }
        } else {
          i++;
        }
        continue;
      }
      
      // REPEAT UNTIL
      if (/^REPEAT\s+UNTIL\s*\(/i.test(s)) {
        const m = s.match(/^REPEAT\s+UNTIL\s*\((.*)\)/i);
        if (m) {
          const condition = m[1];
          i++;
          if (i < end && lines[i].s === "{") {
            const bodyStart = i + 1;
            let depth = 1;
            i++;
            while (i < end && depth > 0) {
              if (lines[i].s === "{") depth++;
              else if (lines[i].s === "}") depth--;
              i++;
            }
            const bodyEnd = i - 1;
            blocks.push({
              type: 'repeat-until',
              condition,
              body: parseBlocksAST(lines, bodyStart, bodyEnd)
            });
          }
        } else {
          i++;
        }
        continue;
      }
      
      // FOR EACH
      if (/^FOR\s+EACH\s+/i.test(s)) {
        const m = s.match(/^FOR\s+EACH\s+(\w+)\s+IN\s+(.+)/i);
        if (m) {
          const itemVar = m[1];
          const listExpr = m[2];
          i++;
          if (i < end && lines[i].s === "{") {
            const bodyStart = i + 1;
            let depth = 1;
            i++;
            while (i < end && depth > 0) {
              if (lines[i].s === "{") depth++;
              else if (lines[i].s === "}") depth--;
              i++;
            }
            const bodyEnd = i - 1;
            blocks.push({
              type: 'for-each',
              itemVar,
              listExpr,
              body: parseBlocksAST(lines, bodyStart, bodyEnd)
            });
          }
        } else {
          i++;
        }
        continue;
      }
      
      // DISPLAY
      if (/^DISPLAY\s*\(/i.test(s)) {
        const m = s.match(/^DISPLAY\s*\((.*)\)/i);
        if (m) {
          blocks.push({ type: 'display', expr: m[1] });
        }
        i++;
        continue;
      }
      
      // RETURN
      if (/^RETURN\s*\(/i.test(s)) {
        const m = s.match(/^RETURN\s*\((.*)\)/i);
        if (m) {
          blocks.push({ type: 'return', expr: m[1] });
        }
        i++;
        continue;
      }
      
      // Assignment with list index
      if (/^[A-Za-z_]\w*\s*\[.*\]\s*(‚Üê|<-)/.test(s)) {
        const m = s.match(/^([A-Za-z_]\w*)\s*\[\s*(.*?)\s*\]\s*(?:‚Üê|<-)\s*(.*)$/);
        if (m) {
          blocks.push({ type: 'list-assign', listName: m[1], index: m[2], value: m[3] });
        }
        i++;
        continue;
      }
      
      // Assignment
      if (/^[A-Za-z_]\w*\s*(‚Üê|<-)/.test(s)) {
        const m = s.match(/^([A-Za-z_]\w*)\s*(?:‚Üê|<-)\s*(.*)$/);
        if (m) {
          blocks.push({ type: 'assign', varName: m[1], expr: m[2] });
        }
        i++;
        continue;
      }
      
      // Procedure call or other function
      if (/^[A-Za-z_]\w*\s*\(/i.test(s)) {
        blocks.push({ type: 'call', expr: s });
        i++;
        continue;
      }
      
      // Unknown - just show as text
      blocks.push({ type: 'unknown', text: s });
      i++;
    }
    
    return blocks;
  }

  function renderBlocksToHtml(blocks) {
    let html = '';
    
    for (const block of blocks) {
      switch (block.type) {
        case 'procedure':
          html += `<div class="block-procedure">
            <span class="block-procedure-header">PROCEDURE ${escapeHtml(block.name)} ${renderVal(block.params)}</span>
            <div class="block-procedure-body">${renderBlocksToHtml(block.body)}</div>
          </div>`;
          break;
          
        case 'if':
          html += `<div class="block-control">
            <span class="block-control-header">IF ${renderCond(block.condition)}</span>
            <div class="block-control-body">${renderBlocksToHtml(block.body)}</div>`;
          if (block.elseBody) {
            html += `<span class="block-else">ELSE</span>
            <div class="block-control-body">${renderBlocksToHtml(block.elseBody)}</div>`;
          }
          html += `</div>`;
          break;
          
        case 'repeat-times':
          html += `<div class="block-control">
            <span class="block-control-header">REPEAT ${renderVal(block.count)} TIMES</span>
            <div class="block-control-body">${renderBlocksToHtml(block.body)}</div>
          </div>`;
          break;
          
        case 'repeat-until':
          html += `<div class="block-control">
            <span class="block-control-header">REPEAT UNTIL ${renderCond(block.condition)}</span>
            <div class="block-control-body">${renderBlocksToHtml(block.body)}</div>
          </div>`;
          break;
          
        case 'for-each':
          html += `<div class="block-control">
            <span class="block-control-header">FOR EACH ${escapeHtml(block.itemVar)} IN ${renderExpression(block.listExpr)}</span>
            <div class="block-control-body">${renderBlocksToHtml(block.body)}</div>
          </div>`;
          break;
          
        case 'display':
          html += `<div class="block-statement"><span class="block-expr">DISPLAY ${renderVal(block.expr)}</span></div>`;
          break;
          
        case 'return':
          html += `<div class="block-statement"><span class="block-expr">RETURN ${renderVal(block.expr)}</span></div>`;
          break;
          
        case 'assign':
          html += `<div class="block-statement"><span class="block-expr">${escapeHtml(block.varName)} ‚Üê ${renderExpression(block.expr)}</span></div>`;
          break;
          
        case 'list-assign':
          html += `<div class="block-statement"><span class="block-expr">${escapeHtml(block.listName)}${renderVal(block.index)} ‚Üê ${renderExpression(block.value)}</span></div>`;
          break;
          
        case 'call':
          html += `<div class="block-statement">${renderExpression(block.expr)}</div>`;
          break;
          
        case 'unknown':
          html += `<div class="block-statement"><span class="block-expr">${escapeHtml(block.text)}</span></div>`;
          break;
      }
    }
    
    return html;
  }

  function renderBlocks() {
    try {
      const lines = preprocess(editor.value);
      const ast = parseBlocksAST(lines, 0, lines.length);
      const html = renderBlocksToHtml(ast);
      blocksBody.innerHTML = `<div class="block-container">${html || '<p style="color:#888;">No code to display</p>'}</div>`;
    } catch (e) {
      blocksBody.innerHTML = `<div class="blocks-error">Error parsing code: ${escapeHtml(String(e))}</div>`;
    }
  }

  // Event Listeners
  $("#runBtn").onclick = () => run(editor.value);
  $("#stopBtn").onclick = () => {
    halted = true;
    if (inputReject) {
      inputReject(new Error("Stopped"));
      hidePrompt();
    }
    setStatus("Stopped", "error");
  };

  $("#copyBtn").onclick = async () => {
    try {
      await navigator.clipboard.writeText(editor.value);
      showToast("Code copied to clipboard!");
    } catch (e) {
      err("Failed to copy code");
    }
  };

  $("#blocksBtn").onclick = () => {
    renderBlocks();
    blocksModal.classList.add("show");
  };

  $("#closeBlocks").onclick = () => blocksModal.classList.remove("show");
  blocksModal.onclick = e => {
    if (e.target === blocksModal) blocksModal.classList.remove("show");
  };

  document.addEventListener("keydown", e => {
    if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
      e.preventDefault();
      $("#runBtn").click();
    }
    if (e.key === "Escape") {
      blocksModal.classList.remove("show");
      helpModal.classList.remove("show");
    }
  });

  $("#helpBtn").onclick = () => helpModal.classList.add("show");
  $("#closeHelp").onclick = () => helpModal.classList.remove("show");
  helpModal.onclick = e => {
    if (e.target === helpModal) helpModal.classList.remove("show");
  };

  const samples = {
    variables: {
      label: "Variables",
      items: {
        "Variables & Types": `num ‚Üê 42\ntext ‚Üê "Hello"\nflag ‚Üê true\n\nDISPLAY(num)\nDISPLAY(text)\nDISPLAY(flag)`,
        "Displaying Variables": `name ‚Üê "Alice"\nage ‚Üê 16\nDISPLAY("Name: " + name)\nDISPLAY("Age: " + age)`,
        "Concatenation": `firstName ‚Üê "Ada"\nlastName ‚Üê "Lovelace"\nfullName ‚Üê firstName + " " + lastName\nDISPLAY(fullName)\n\nscore ‚Üê 95\nDISPLAY("Your score is: " + score)`,
        "Swapping Values": `a ‚Üê 10\nb ‚Üê 20\nDISPLAY("Before: a = " + a + ", b = " + b)\n\ntemp ‚Üê a\na ‚Üê b\nb ‚Üê temp\n\nDISPLAY("After: a = " + a + ", b = " + b)`,
        "Booleans & Comparisons": `x ‚Üê 8\ny ‚Üê 10\n\nDISPLAY("x = " + x + ", y = " + y)\nDISPLAY("x > y is: " + (x > y))\nDISPLAY("x < y is: " + (x < y))\nDISPLAY("x = y is: " + (x = y))\nDISPLAY("x ‚â† y is: " + (x ‚â† y))`,
        "Boolean Logic": `a ‚Üê true\nb ‚Üê false\n\nDISPLAY("a AND b: " + (a AND b))\nDISPLAY("a OR b: " + (a OR b))\nDISPLAY("NOT a: " + (NOT a))`,
        "MOD Operator": `DISPLAY("17 MOD 5 = " + (17 MOD 5))\nDISPLAY("10 MOD 3 = " + (10 MOD 3))\n\nnum ‚Üê 7\nIF(num MOD 2 = 0)\n{\n   DISPLAY(num + " is even")\n}\nELSE\n{\n   DISPLAY(num + " is odd")\n}`,
        "RANDOM Function": `roll ‚Üê RANDOM(1, 6)\nDISPLAY("Dice roll: " + roll)\n\ncoin ‚Üê RANDOM(1, 2)\nIF(coin = 1)\n{\n   DISPLAY("Heads!")\n}\nELSE\n{\n   DISPLAY("Tails!")\n}`
      }
    },
    conditionals: {
      label: "Conditionals",
      items: {
        "IF Statement": `age ‚Üê 18\nIF(age ‚â• 18)\n{\n   DISPLAY("You can vote!")\n}`,
        "IF-ELSE": `score ‚Üê 75\nIF(score ‚â• 60)\n{\n   DISPLAY("You passed!")\n}\nELSE\n{\n   DISPLAY("Try again.")\n}`,
        "Nested IF": `grade ‚Üê 85\n\nIF(grade ‚â• 90)\n{\n   DISPLAY("A")\n}\nELSE\n{\n   IF(grade ‚â• 80)\n   {\n      DISPLAY("B")\n   }\n   ELSE\n   {\n      IF(grade ‚â• 70)\n      {\n         DISPLAY("C")\n      }\n      ELSE\n      {\n         DISPLAY("Below C")\n      }\n   }\n}`,
        "Boolean Conditions": `x ‚Üê 15\nIF(x > 10 AND x < 20)\n{\n   DISPLAY("x is between 10 and 20")\n}`,
        "NOT Operator": `isRaining ‚Üê false\nIF(NOT isRaining)\n{\n   DISPLAY("Go outside!")\n}\nELSE\n{\n   DISPLAY("Take an umbrella")\n}`
      }
    },
    loops: {
      label: "Loops",
      items: {
        "REPEAT n TIMES": `REPEAT 5 TIMES\n{\n   DISPLAY("Hello!")\n}`,
        "REPEAT with Counter": `count ‚Üê 1\nREPEAT 5 TIMES\n{\n   DISPLAY("Count: " + count)\n   count ‚Üê count + 1\n}`,
        "REPEAT UNTIL": `num ‚Üê 1\nREPEAT UNTIL(num > 5)\n{\n   DISPLAY(num)\n   num ‚Üê num + 1\n}`,
        "FOR EACH with List": `colors ‚Üê ["red", "green", "blue"]\nFOR EACH color IN colors\n{\n   DISPLAY(color)\n}`,
        "Sum with FOR EACH": `numbers ‚Üê [10, 20, 30, 40]\nsum ‚Üê 0\nFOR EACH num IN numbers\n{\n   sum ‚Üê sum + num\n}\nDISPLAY("Sum: " + sum)`
      }
    },
    lists: {
      label: "Lists",
      items: {
        "Create & Access": `myList ‚Üê [10, 20, 30, 40]\nDISPLAY(myList[1])\nDISPLAY(myList[3])\nDISPLAY("Length: " + LENGTH(myList))\nDISPLAY("Full list: " + myList)`,
        "Modify Elements": `nums ‚Üê [5, 10, 15]\nDISPLAY("Before: " + nums)\nnums[2] ‚Üê 99\nDISPLAY("After: " + nums)`,
        "APPEND": `items ‚Üê [1, 2, 3]\nDISPLAY("Before: " + items)\nAPPEND(items, 4)\nAPPEND(items, 5)\nDISPLAY("After: " + items)`,
        "INSERT": `letters ‚Üê ["A", "C", "D"]\nDISPLAY("Before: " + letters)\nINSERT(letters, 2, "B")\nDISPLAY("After: " + letters)`,
        "REMOVE": `data ‚Üê [10, 20, 30, 40]\nDISPLAY("Before: " + data)\nREMOVE(data, 2)\nDISPLAY("After: " + data)`,
        "Search in List": `names ‚Üê ["Alice", "Bob", "Charlie"]\nsearchFor ‚Üê "Bob"\nfound ‚Üê false\n\nFOR EACH name IN names\n{\n   IF(name = searchFor)\n   {\n      found ‚Üê true\n   }\n}\n\nIF(found)\n{\n   DISPLAY(searchFor + " was found!")\n}\nELSE\n{\n   DISPLAY(searchFor + " was not found.")\n}`
      }
    },
    strings: {
      label: "Strings",
      items: {
        "CONTAINS": `email ‚Üê "user@example.com"\n\nIF(CONTAINS(email, "@"))\n{\n   DISPLAY("Valid email format!")\n}\nELSE\n{\n   DISPLAY("Invalid email!")\n}`,
        "SUBSTRING": `text ‚Üê "HELLO WORLD"\n\nDISPLAY("Full text: " + text)\nDISPLAY("First 5 chars: " + SUBSTRING(text, 1, 5))\nDISPLAY("Last 5 chars: " + SUBSTRING(text, 7, 11))`,
        "String Indexing": `word ‚Üê "APPLE"\n\nDISPLAY("First letter: " + word[1])\nDISPLAY("Third letter: " + word[3])\nDISPLAY("Last letter: " + word[LENGTH(word)])`,
        "Iterate Over String": `word ‚Üê "CODE"\n\nFOR EACH letter IN word\n{\n   DISPLAY(letter)\n}`,
        "Spam Filter": `emails ‚Üê ["You won a prize!", "Meeting tomorrow", "WINNER! Click here", "Project update"]\nspamList ‚Üê []\n\nFOR EACH item IN emails\n{\n   IF(CONTAINS(item, "WINNER") OR CONTAINS(item, "won"))\n   {\n      APPEND(spamList, item)\n   }\n}\n\nDISPLAY("Spam messages found:")\nFOR EACH spam IN spamList\n{\n   DISPLAY("  - " + spam)\n}`,
        "Case Conversion": `text ‚Üê "Hello World"\n\nDISPLAY("Original: " + text)\nDISPLAY("Uppercase: " + UPPERCASE(text))\nDISPLAY("Lowercase: " + LOWERCASE(text))`,
        "Extract Domain": `email ‚Üê "student@school.edu"\natPos ‚Üê 0\nindex ‚Üê 1\n\nREPEAT UNTIL(index > LENGTH(email))\n{\n   IF(email[index] = "@")\n   {\n      atPos ‚Üê index\n   }\n   index ‚Üê index + 1\n}\n\ndomain ‚Üê SUBSTRING(email, atPos + 1, LENGTH(email))\nDISPLAY("Domain: " + domain)`
      }
    },
    procedures: {
      label: "Procedures",
      items: {
        "Simple Procedure": `PROCEDURE greet(name)\n{\n   DISPLAY("Hello, " + name + "!")\n}\n\ngreet("Alice")\ngreet("Bob")`,
        "Procedure with Return": `PROCEDURE square(n)\n{\n   RETURN(n * n)\n}\n\nresult ‚Üê square(5)\nDISPLAY("5 squared is " + result)`,
        "Multiple Parameters": `PROCEDURE add(a, b)\n{\n   RETURN(a + b)\n}\n\nsum ‚Üê add(10, 25)\nDISPLAY("10 + 25 = " + sum)`,
        "Procedure Calling Procedure": `PROCEDURE double(x)\n{\n   RETURN(x * 2)\n}\n\nPROCEDURE quadruple(x)\n{\n   RETURN(double(double(x)))\n}\n\nDISPLAY(quadruple(5))`
      }
    },
    programs: {
      label: "Program Samples",
      items: {
        "1. Variables & Booleans": `name ‚Üê "Student"\nscore1 ‚Üê 85\nscore2 ‚Üê 92\n\nDISPLAY("Welcome, " + name + "!")\nDISPLAY("Score 1: " + score1)\nDISPLAY("Score 2: " + score2)\n\naverage ‚Üê (score1 + score2) / 2\nDISPLAY("Average: " + average)\n\nDISPLAY("Score1 > Score2: " + (score1 > score2))\nDISPLAY("Both above 80: " + (score1 > 80 AND score2 > 80))`,
        "2. Variables & IF": `DISPLAY("Enter your score:")\nscore ‚Üê INPUT()\n\nIF(score ‚â• 90)\n{\n   grade ‚Üê "A"\n}\nELSE\n{\n   IF(score ‚â• 80)\n   {\n      grade ‚Üê "B"\n   }\n   ELSE\n   {\n      IF(score ‚â• 70)\n      {\n         grade ‚Üê "C"\n      }\n      ELSE\n      {\n         grade ‚Üê "F"\n      }\n   }\n}\n\nDISPLAY("Grade: " + grade)`,
        "3. Variables, List & IF": `scores ‚Üê [78, 92, 65, 88, 95, 71]\nDISPLAY("Scores: " + scores)\n\nmax ‚Üê scores[1]\nFOR EACH score IN scores\n{\n   IF(score > max)\n   {\n      max ‚Üê score\n   }\n}\n\nDISPLAY("Highest score: " + max)\n\nIF(max ‚â• 90)\n{\n   DISPLAY("Top score is an A!")\n}`,
        "4. List, Loop & IF": `grades ‚Üê [85, 42, 78, 95, 55, 67, 88, 39]\npassingCount ‚Üê 0\nfailingCount ‚Üê 0\n\nFOR EACH grade IN grades\n{\n   IF(grade ‚â• 60)\n   {\n      passingCount ‚Üê passingCount + 1\n   }\n   ELSE\n   {\n      failingCount ‚Üê failingCount + 1\n   }\n}\n\nDISPLAY("All grades: " + grades)\nDISPLAY("Number passing: " + passingCount)\nDISPLAY("Number failing: " + failingCount)`,
        "5. Procedures & Return": `PROCEDURE calculateSum(numList)\n{\n   total ‚Üê 0\n   FOR EACH num IN numList\n   {\n      total ‚Üê total + num\n   }\n   RETURN(total)\n}\n\nPROCEDURE findMax(numList)\n{\n   maxVal ‚Üê numList[1]\n   FOR EACH num IN numList\n   {\n      IF(num > maxVal)\n      {\n         maxVal ‚Üê num\n      }\n   }\n   RETURN(maxVal)\n}\n\ndata ‚Üê [23, 67, 45, 89, 12, 56]\nDISPLAY("Data: " + data)\nDISPLAY("Sum: " + calculateSum(data))\nDISPLAY("Max: " + findMax(data))`,
        "6. Login System (Full)": `usernames ‚Üê ["admin", "student1", "teacher"]\npasswords ‚Üê ["pass123", "learn456", "teach789"]\n\nPROCEDURE checkCredentials(inputUser, inputPass)\n{\n   index ‚Üê 1\n   FOR EACH user IN usernames\n   {\n      IF(user = inputUser)\n      {\n         IF(passwords[index] = inputPass)\n         {\n            RETURN(true)\n         }\n      }\n      index ‚Üê index + 1\n   }\n   RETURN(false)\n}\n\nPROCEDURE login(user, pass)\n{\n   isValid ‚Üê checkCredentials(user, pass)\n   IF(isValid)\n   {\n      DISPLAY("ACCESS GRANTED")\n   }\n   ELSE\n   {\n      DISPLAY("INTRUDER ALERT")\n   }\n   RETURN(isValid)\n}\n\nDISPLAY("Enter username:")\nenteredUser ‚Üê INPUT()\nDISPLAY("Enter password:")\nenteredPass ‚Üê INPUT()\n\nresult ‚Üê login(enteredUser, enteredPass)`
      }
    }
  };

  const samplesMenu = $("#samplesMenu");
  const categoryIcons = { variables: "x", conditionals: "?", loops: "‚Üª", procedures: "∆í", lists: "[ ]", strings: "\" \"", programs: "‚óÜ" };

  for (const [catKey, category] of Object.entries(samples)) {
    const catEl = document.createElement("div");
    catEl.className = "dropdown-category";
    catEl.textContent = category.label;
    samplesMenu.appendChild(catEl);

    for (const [name, code] of Object.entries(category.items)) {
      const item = document.createElement("div");
      item.className = `dropdown-item cat-${catKey}`;
      item.innerHTML = `<span class="icon">${categoryIcons[catKey]}</span>${name}`;
      item.onclick = () => {
        editor.value = code;
        updateLineNumbers();
        samplesMenu.classList.remove("show");
      };
      samplesMenu.appendChild(item);
    }
  }

  const samplesBtn = $("#samplesBtn");
  samplesBtn.onclick = (e) => {
    e.stopPropagation();
    samplesMenu.classList.toggle("show");
  };

  document.addEventListener("click", () => samplesMenu.classList.remove("show"));
  samplesMenu.onclick = (e) => e.stopPropagation();

  editor.value = `DISPLAY("Welcome to AP CSP Console v2.7!")`;
  updateLineNumbers();

  const resizer = $("#resizer");
  const mainEl = $("main");
  let isResizing = false;

  resizer.addEventListener("mousedown", (e) => {
    isResizing = true;
    document.body.style.cursor = "col-resize";
    e.preventDefault();
  });

  document.addEventListener("mousemove", (e) => {
    if (!isResizing) return;
    const mainRect = mainEl.getBoundingClientRect();
    const offsetX = e.clientX - mainRect.left;
    const percentage = (offsetX / mainRect.width) * 100;
    if (percentage > 20 && percentage < 80) {
      mainEl.style.gridTemplateColumns = `${percentage}fr ${100 - percentage}fr`;
      resizer.style.left = `calc(${percentage}% - 6px)`;
    }
  });

  document.addEventListener("mouseup", () => {
    if (isResizing) {
      isResizing = false;
      document.body.style.cursor = "";
    }
  });

  setStatus("Ready");
  sys("‚úì Emulator ready. Press Run to execute.");
});
</script>
</body>
</html>
