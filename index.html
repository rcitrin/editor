<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TBA PSEUDOCODE CONSOLE</title>

  <style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');


:root {
  --bg: #000000;
  --bg-elevated: #0a0a0a;
  --panel-bg: #111111;
  --panel-bg-hover: #1a1a1a;
  --border: #222222;
  --border-subtle: #1a1a1a;
  --text-primary: #f0f0f0;
  --text-secondary: #a0a0a0;
  --text-muted: #666666;

  --accent: #93c83a;
  --accent-hover: #7FAD5D;
  --accent-glow: rgba(101, 136, 26, 0.25);

  --danger: #B5514D;
  --danger-hover: #B5514D;

  --editor-caret: #519BB0;

  --gradient-1: linear-gradient(135deg, #007BA7 0%, #007BA7 100%);
  
  --btn-secondary-bg: #2a2a2a;
  --btn-secondary-border: #3a3a3a;
  --btn-secondary-hover: #383838;
}

body.light-mode {
  --bg: #f5f5f5;
  --bg-elevated: #ffffff;
  --panel-bg: #ffffff;
  --panel-bg-hover: #f0f0f0;
  --border: #d0d0d0;
  --text-primary: #1a1a1a;
  --text-secondary: #555555;
  --text-muted: #888888;
  --btn-secondary-bg: #e8e8e8;
  --btn-secondary-border: #ccc;
  --btn-secondary-hover: #ddd;
}
* { box-sizing: border-box; margin: 0; padding: 0; }

html, body { 
  margin: 0; 
  padding: 0;
  height: 100%;
  overflow: hidden;
}

body {
  background: var(--bg);
  color: var(--text-primary);
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  font-size: 14px;
  line-height: 1.5;
  display: flex;
  flex-direction: column;
  height: 100vh;
}

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-track {
  background: var(--bg);
}
::-webkit-scrollbar-thumb {
  background: #333;
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background: #444;
}

header {
  padding: 16px 24px;
  background: var(--bg);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-shrink: 0;
}

.logo {
  display: flex;
  align-items: center;
  gap: 12px;
}

.logo-icon {
  width: 36px;
  height: 36px;
  background: #8A3F8E;
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 18px;
  color: #000;
  box-shadow: 0 4px 12px var(--accent-glow);
}

.logo-text {
  font-size: 18px;
  font-weight: 600;
  letter-spacing: -0.5px;
}

.logo-text span {
  background: var(--gradient-1);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.header-actions {
  display: flex;
  gap: 8px;
}

main {
  flex: 1;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1px;
  background: var(--border);
  min-height: 0;
  position: relative;
}

.resizer {
  position: absolute;
  width: 12px;
  height: 100%;
  background: transparent;
  cursor: col-resize;
  top: 0;
  left: calc(50% - 6px);
  z-index: 100;
  display: flex;
  align-items: center;
  justify-content: center;
}

.resizer::after {
  content: '';
  width: 4px;
  height: 48px;
  background: var(--border);
  border-radius: 2px;
  transition: all 0.2s ease;
}

.resizer:hover::after {
  background: var(--accent);
  height: 64px;
  box-shadow: 0 0 12px var(--accent-glow);
}

.panel {
  background: var(--panel-bg);
  display: flex;
  flex-direction: column;
  min-height: 0;
  overflow: hidden;
}

.panel-header {
  padding: 12px 16px;
  background: var(--bg);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.panel-header h2 {
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--text-muted);
  margin: 0;
}

.panel-header .dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--accent);
  box-shadow: 0 0 8px var(--accent);
}

.toolbar {
  padding: 12px 16px;
  background: var(--bg-elevated);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  flex-shrink: 0;
}

.toolbar-group {
  display: flex;
  gap: 6px;
}

.toolbar-divider {
  width: 1px;
  height: 28px;
  background: var(--border);
  margin: 0 8px;
}

button {
  font-family: 'Inter', sans-serif;
  font-size: 13px;
  font-weight: 500;
  padding: 8px 14px;
  border-radius: 8px;
  border: 1px solid var(--border);
  background: var(--panel-bg);
  color: var(--text-primary);
  cursor: pointer;
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  gap: 6px;
}

button:hover {
  background: var(--panel-bg-hover);
  border-color: #333;
}

button.primary {
  background: var(--accent);
  border-color: var(--accent);
  color: #000;
  font-weight: 600;
}

button.primary:hover {
  background: var(--accent-hover);
  border-color: var(--accent-hover);
  box-shadow: 0 4px 12px var(--accent-glow);
}

button.danger {
  background: transparent;
  border-color: var(--danger);
  color: var(--danger);
}

button.danger:hover {
  background: var(--danger);
  color: #fff;
}

button.ghost {
  background: var(--btn-secondary-bg);
  border-color: var(--btn-secondary-border);
}

button.ghost:hover {
  background: var(--btn-secondary-hover);
  border-color: #4a4a4a;
}

.dropdown {
  position: relative;
}

.dropdown-trigger {
  min-width: 140px;
  justify-content: space-between;
}

.dropdown-trigger::after {
  content: '‚ñæ';
  font-size: 10px;
  opacity: 0.6;
}

.dropdown-menu {
  position: absolute;
  top: calc(100% + 4px);
  left: 0;
  min-width: 220px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 6px;
  box-shadow: 0 16px 48px rgba(0,0,0,0.5);
  z-index: 1000;
  display: none;
  max-height: 400px;
  overflow-y: auto;
}

.dropdown-menu.show {
  display: block;
  animation: dropdownIn 0.15s ease;
}

@keyframes dropdownIn {
  from { opacity: 0; transform: translateY(-8px); }
  to { opacity: 1; transform: translateY(0); }
}

.dropdown-category {
  padding: 8px 12px 6px;
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  gap: 8px;
}

.dropdown-category::after {
  content: '';
  flex: 1;
  height: 1px;
  background: var(--border);
}

.dropdown-item {
  padding: 10px 12px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 13px;
  color: var(--text-secondary);
  transition: all 0.1s ease;
  display: flex;
  align-items: center;
  gap: 10px;
}

.dropdown-item:hover {
  background: var(--panel-bg-hover);
  color: var(--text-primary);
}

.dropdown-item .icon {
  width: 20px;
  height: 20px;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  flex-shrink: 0;
}

.dropdown-item.cat-variables .icon { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
.dropdown-item.cat-conditionals .icon { background: rgba(168, 85, 247, 0.2); color: #a855f7; }
.dropdown-item.cat-loops .icon { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
.dropdown-item.cat-procedures .icon { background: rgba(236, 72, 153, 0.2); color: #ec4899; }
.dropdown-item.cat-lists .icon { background: rgba(245, 158, 11, 0.2); color: #f59e0b; }
.dropdown-item.cat-programs .icon { background: rgba(6, 182, 212, 0.2); color: #06b6d4; }

.editor-wrapper {
  flex: 1;
  display: flex;
  overflow: hidden;
  background: var(--editor-bg);
}

.line-numbers {
  padding: 16px 12px;
  background: var(--editor-bg);
  color: var(--text-muted);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 14px;
  line-height: 1.6;
  text-align: right;
  user-select: none;
  border-right: 1px solid var(--border);
  min-width: 48px;
  overflow: hidden;
  white-space: pre;
}

textarea {
  flex: 1;
  padding: 16px;
  background: var(--editor-bg);
  color: var(--editor-text);
  border: none;
  outline: none;
  resize: none;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 14px;
  line-height: 1.6;
  caret-color: var(--editor-caret);
  overflow: auto;
}

textarea::placeholder {
  color: var(--text-muted);
}

.console {
  flex: 1;
  overflow: auto;
  padding: 16px;
  background: var(--console-bg);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 13px;
  line-height: 1.7;
}

.console .line {
  padding: 2px 0;
  border-radius: 4px;
}

.console .log { color: var(--console-log); }
.console .err { color: var(--console-err); }
.console .sys { color: var(--console-sys); }
.console .help { 
  color: var(--console-help); 
  background: rgba(251, 191, 36, 0.1);
  padding: 8px 12px;
  margin: 8px 0;
  border-radius: 8px;
  border-left: 3px solid var(--console-help);
}
.console .help-title {
  font-weight: 600;
  margin-bottom: 4px;
}
.console .help-code {
  background: rgba(0,0,0,0.3);
  padding: 8px 12px;
  border-radius: 6px;
  margin-top: 8px;
  font-size: 12px;
  white-space: pre;
}

.prompt-wrap {
  display: none;
  padding: 12px 16px;
  background: var(--bg-elevated);
  border-top: 1px solid var(--border);
  gap: 8px;
  align-items: center;
  flex-shrink: 0;
}

.prompt-wrap.show {
  display: flex;
}

.prompt-wrap input {
  flex: 1;
  padding: 10px 14px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--text-primary);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 14px;
  outline: none;
  transition: border-color 0.15s ease;
}

.prompt-wrap input:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-glow);
}

.status {
  padding: 8px 16px;
  background: var(--bg);
  border-top: 1px solid var(--border);
  font-size: 12px;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.status-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: var(--text-muted);
}

.status-dot.running {
  background: var(--accent);
  animation: pulse 1s infinite;
}

.status-dot.error {
  background: var(--danger);
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

footer {
  padding: 12px 24px;
  background: var(--bg);
  border-top: 1px solid var(--border);
  text-align: center;
  font-size: 12px;
  color: var(--text-muted);
  flex-shrink: 0;
}

footer a {
  color: var(--accent);
  text-decoration: none;
}

.toast {
  position: fixed;
  bottom: 80px;
  left: 50%;
  transform: translateX(-50%) translateY(20px);
  background: var(--panel-bg);
  border: 1px solid var(--border);
  padding: 12px 20px;
  border-radius: 10px;
  font-size: 13px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  opacity: 0;
  pointer-events: none;
  transition: all 0.2s ease;
  z-index: 2000;
}

.toast.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

.kbd-hint {
  margin-left: auto;
  font-size: 11px;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  gap: 4px;
}

kbd {
  padding: 2px 6px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  font-family: 'Inter', sans-serif;
  font-size: 10px;
}

.help-modal, .blocks-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.8);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 3000;
  backdrop-filter: blur(4px);
}

.help-modal.show, .blocks-modal.show {
  display: flex;
}

.help-content {
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 16px;
  width: 90%;
  max-width: 600px;
  max-height: 80vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: 0 24px 64px rgba(0,0,0,0.5);
}

.help-header {
  padding: 20px 24px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.help-header h3 {
  font-size: 18px;
  font-weight: 600;
}

.help-body {
  padding: 24px;
  overflow-y: auto;
  font-size: 14px;
  line-height: 1.7;
}

.help-section {
  margin-bottom: 24px;
}

.help-section h4 {
  font-size: 13px;
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.help-section pre {
  background: var(--bg);
  padding: 16px;
  border-radius: 8px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 13px;
  overflow-x: auto;
  border: 1px solid var(--border);
}

/* Blocks Modal */
.blocks-content {
  background: #ffffff;
  border: 1px solid #ccc;
  border-radius: 8px;
  width: 95%;
  max-width: 900px;
  max-height: 90vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: 0 24px 64px rgba(0,0,0,0.3);
}

.blocks-header {
  padding: 12px 20px;
  background: #f5f5f5;
  border-bottom: 1px solid #ddd;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.blocks-header h3 {
  font-size: 16px;
  font-weight: 600;
  color: #333;
  display: flex;
  align-items: center;
  gap: 8px;
}

.blocks-header .close-btn {
  background: #e9ecef;
  border: 1px solid #ccc;
  color: #333;
  padding: 6px 12px;
  font-size: 12px;
}

.blocks-header .close-btn:hover {
  background: #ddd;
}

.blocks-body {
  padding: 20px;
  overflow-y: auto;
  background: #ffffff;
  min-height: 200px;
}

/* APCSP Block Styles - Matching Official Exam Format */
#APblocks, .block-container {
  font-family: monospace;
  font-size: 14px;
  color: #000;
}

.block-statement {
  display: block;
  margin: 1px 0;
}

/* bl - Rounded Rectangle Block (most statements) */
.bl, .block-expr {
  border: solid 1px black;
  border-radius: 5px;
  font-family: monospace;
  padding: 2px 5px;
  background-color: white;
  display: inline-block;
  margin-top: 1px;
}

/* val - Square Rectangle (arguments, parameters, expressions) */
.val, .block-val {
  border: solid 1px black;
  border-radius: 0px;
  margin: 1px;
  padding: 2px 3px;
  display: inline-block;
  background-color: white;
}

/* cond - Oval (conditions) */
.cond, .block-cond {
  border: solid 1px black;
  border-radius: 30px;
  padding: 1px 10px;
  display: inline-block;
  background-color: white;
}

/* Dark/Gray blocks for IF, REPEAT, PROCEDURE, FOR */
.dark, .block-control {
  background-color: #dddddd;
  border: solid 1px black;
  border-radius: 5px;
  padding: 5px;
  padding-top: 5px;
  margin: 1px 0;
  display: block;
}

.block-control-header {
  display: inline;
}

.block-control-body {
  display: block;
  margin-left: 16px;
  margin-top: 1px;
}

.block-procedure {
  background-color: #dddddd;
  border: solid 1px black;
  border-radius: 5px;
  padding: 5px;
  padding-top: 5px;
  margin: 1px 0;
  display: block;
}

.block-procedure-header {
  display: inline;
}

.block-procedure-body {
  display: block;
  margin-left: 16px;
  margin-top: 1px;
}

.block-keyword {
  font-weight: normal;
  font-family: monospace;
}

.block-arrow {
  font-family: monospace;
}

.block-list {
  border: solid 1px black;
  border-radius: 0px;
  padding: 2px 3px;
  display: inline-block;
  background-color: white;
}

.block-else {
  margin-top: 1px;
  font-family: monospace;
  display: block;
}

.blocks-error {
  background: #fff3f3;
  border: 1px solid #ffcdd2;
  border-radius: 5px;
  padding: 12px;
  color: #c62828;
  font-size: 14px;
}

@media (max-width: 768px) {
  main {
    grid-template-columns: 1fr;
    grid-template-rows: 1fr 1fr;
  }
  
  .resizer {
    width: 100%; 
    height: 12px;
    top: calc(50% - 6px);
    left: 0;
    cursor: row-resize;
  }
  
  .resizer::after {
    width: 48px;
    height: 4px;
  }
  
  .toolbar {
    flex-wrap: wrap;
  }
  
  .kbd-hint {
    display: none;
  }
}
</style>
</head>

<body>
<header>
  <div class="logo">
    <div class="logo-icon">C</div>
    <div class="logo-text"><span>CITRIN: </span>  TBA PSEUDOCODE CONSOLE <span> (v2.61)</span> </div>
  </div>

  <div class="header-actions">
<button class="ghost" id="themeBtn" title="Toggle Light/Dark Mode">
  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
</button>

    <button class="ghost" id="helpBtn" title="Syntax Reference">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="10"></circle>
        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
        <line x1="12" y1="17" x2="12.01" y2="17"></line>
      </svg>
      Help
    </button>
  </div>
</header>

<main>
  <div class="resizer" id="resizer"></div>
  
  <section class="panel">
    <div class="panel-header">
      <div class="dot"></div>
      <h2>Program Editor (INPUT)</h2>
    </div>
    <div class="toolbar">
      <div class="toolbar-group">
        <button class="primary" id="runBtn">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
            <polygon points="5 3 19 12 5 21 5 3"></polygon>
          </svg>
          Run
        </button>
        <button class="danger" id="stopBtn">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          </svg>
          Stop
        </button>
      </div>
      
      <div class="toolbar-divider"></div>
      
      <div class="toolbar-group">
        <button id="copyBtn" class="ghost">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
          Copy
        </button>
        <button id="blocksBtn" class="ghost">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="7" height="7" rx="1"></rect>
            <rect x="14" y="3" width="7" height="7" rx="1"></rect>
            <rect x="3" y="14" width="7" height="7" rx="1"></rect>
            <rect x="14" y="14" width="7" height="7" rx="1"></rect>
          </svg>
          Blocks
        </button>
      </div>
      
      <div class="toolbar-divider"></div>
      
      <div class="dropdown">
        <button class="dropdown-trigger ghost" id="samplesBtn">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path>
            <polyline points="14 2 14 8 20 8"></polyline>
          </svg>
          Examples
        </button>
        <div class="dropdown-menu" id="samplesMenu"></div>
      </div>
      
      <div class="kbd-hint">
        <kbd>Ctrl</kbd> + <kbd>Enter</kbd> to run
      </div>
    </div>
    <div class="editor-wrapper">
      <div class="line-numbers" id="lineNumbers"></div>
      <textarea id="editor" placeholder="Write your APCSP pseudocode here..." spellcheck="false"></textarea>
    </div>
  </section>

  <section class="panel">
    <div class="panel-header">
      <div class="dot"></div>
      <h2>Console (Output)</h2>
    </div>
    <div class="console" id="console"></div>
    <div class="prompt-wrap" id="promptWrap">
      <input id="promptInput" placeholder="Enter input‚Ä¶" />
      <button id="promptOk" class="primary">Submit</button>
      <button id="promptCancel">Cancel</button>
    </div>
    <div class="status" id="status">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Ready</span>
    </div>
  </section>
</main>

<footer>
  @Citrin ‚Ä¢ TechBoston Academy
</footer>

<div class="toast" id="toast"></div>

<div class="help-modal" id="helpModal">
  <div class="help-content">
    <div class="help-header">
      <h3>üìñ APCSP Syntax Reference</h3>
      <button class="ghost" id="closeHelp">‚úï</button>
    </div>
    <div class="help-body">
      <div class="help-section">
        <h4>Assignment, Display, and Input</h4>
        <pre>a ‚Üê expression
DISPLAY(expression)
INPUT()</pre>
      </div>
      <div class="help-section">
        <h4>Arithmetic Operators</h4>
        <pre>a + b    a - b    a * b    a / b
a MOD b</pre>
      </div>
      <div class="help-section">
        <h4>Relational and Boolean Operators</h4>
        <pre>a = b    a ‚â† b    a > b    a < b    a ‚â• b    a ‚â§ b
NOT condition
condition1 AND condition2
condition1 OR condition2</pre>
      </div>
      <div class="help-section">
        <h4>Selection</h4>
        <pre>IF(condition)
{
   &lt;block of statements&gt;
}

IF(condition)
{
   &lt;first block of statements&gt;
}
ELSE
{
   &lt;second block of statements&gt;
}</pre>
      </div>
      <div class="help-section">
        <h4>Iteration</h4>
        <pre>REPEAT n TIMES
{
   &lt;block of statements&gt;
}

REPEAT UNTIL(condition)
{
   &lt;block of statements&gt;
}</pre>
      </div>
      <div class="help-section">
        <h4>List Operations</h4>
        <pre>aList ‚Üê [value1, value2, value3]
aList[i]
x ‚Üê aList[i]
aList[i] ‚Üê x
INSERT(aList, i, value)
APPEND(aList, value)
REMOVE(aList, i)
LENGTH(aList)

FOR EACH item IN aList
{
   &lt;block of statements&gt;
}</pre>
      </div>
      <div class="help-section">
        <h4>Procedures</h4>
        <pre>PROCEDURE procName(parameter1, parameter2, ...)
{
   &lt;block of statements&gt;
}

PROCEDURE procName(parameter1, parameter2, ...)
{
   &lt;block of statements&gt;
   RETURN(expression)
}</pre>
      </div>
      <div class="help-section">
        <h4>Built-in Functions</h4>
        <pre>RANDOM(a, b)
LENGTH(aList)</pre>
      </div>
    </div>
  </div>
</div>

<div class="blocks-modal" id="blocksModal">
  <div class="blocks-content">
    <div class="blocks-header">
      <h3>
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="7" height="7" rx="1"></rect>
          <rect x="14" y="3" width="7" height="7" rx="1"></rect>
          <rect x="3" y="14" width="7" height="7" rx="1"></rect>
          <rect x="14" y="14" width="7" height="7" rx="1"></rect>
        </svg>
        Block View (OUTPUT)
      </h3>
      <button class="ghost" id="closeBlocks">‚úï</button>
    </div>
    <div class="blocks-body" id="blocksBody">
      <div style="text-align:center; padding: 40px;">
        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#ccc" stroke-width="2">
          <rect x="3" y="3" width="7" height="7" rx="1"></rect>
          <rect x="14" y="3" width="7" height="7" rx="1"></rect>
          <rect x="3" y="14" width="7" height="7" rx="1"></rect>
          <rect x="14" y="14" width="7" height="7" rx="1"></rect>
        </svg>
        <p style="color: #888; margin-top: 10px;">Rendered blocks will appear here after clicking 'Blocks'</p>
      </div>
    </div>
  </div>
</div>

<script>
const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);

const editor = $("#editor");
const lineNumbers = $("#lineNumbers");
const logEl = $("#console");
const promptWrap = $("#promptWrap");
const promptInput = $("#promptInput");
const promptOk = $("#promptOk");
const promptCancel = $("#promptCancel");
const statusDot = $("#statusDot");
const statusText = $("#statusText");
const blocksModal = $("#blocksModal");
const blocksBody = $("#blocksBody");
const toastEl = $("#toast");

let inputResolve = null;
let inputReject = null;
let halted = false;

// ===== UTILITIES =====

function updateLineNumbers() {
  const lines = editor.value.split(/\r?\n/);
  lineNumbers.innerHTML = lines.map((_, i) => i + 1).join('\n');
}

function showToast(message) {
  toastEl.textContent = message;
  toastEl.classList.add("show");
  setTimeout(() => toastEl.classList.remove("show"), 3000);
}

function formatValue(val) {
  if (typeof val === "boolean") return val ? "true" : "false";
  if (val === null) return "null";
  if (val === undefined) return "undefined";
  if (typeof val === "string") return `"${val}"`;
  if (Array.isArray(val)) {
    return "[" + val.map(v => {
      if (Array.isArray(v)) return formatValue(v); 
      return String(v); 
    }).join(", ") + "]";
  }
  return String(val);
}

const out = (m, c = "log") => {
  const d = document.createElement("div");
  d.className = "line " + c;
  if (typeof m === 'object' && m !== null && m.html) {
    d.innerHTML = m.html;
  } else {
    d.textContent = formatValue(m);
  }
  logEl.appendChild(d);
  logEl.scrollTop = logEl.scrollHeight;
};

const log = m => out(m, "log");
const err = m => out(m, "err");
const sys = m => out(m, "sys");
const help = (title, description, example) => {
  out({ html: `<div class="help-title">üí° ${title}</div>${description}<div class="help-code">${example}</div>` }, "help");
};

const setStatus = (s, state = "idle") => {
  statusText.textContent = s;
  statusDot.className = "status-dot";
  if (state === "running") statusDot.classList.add("running");
  if (state === "error") statusDot.classList.add("error");
};

const syntaxHelp = {
  procedure: { title: "PROCEDURE Syntax Error", desc: "Procedures must follow this exact format:", example: `PROCEDURE procName(parameter1, parameter2)\n{\n <block of statements>\n RETURN(expression)\n}` },
  if: { title: "IF Statement Syntax Error", desc: "IF statements require parentheses around the condition:", example: `IF(condition)\n{\n <block of statements>\n}\nELSE\n{\n <block of statements>\n}` },
  nestedIf: { title: "Nested IF Syntax", desc: "You can nest IF statements inside each other:", example: `IF(condition1)\n{\n IF(condition2)\n {\n <statements>\n }\n}` },
  repeatTimes: { title: "REPEAT TIMES Syntax Error", desc: "The REPEAT n TIMES loop format:", example: `REPEAT n TIMES\n{\n <block of statements>\n}` },
  repeatUntil: { title: "REPEAT UNTIL Syntax Error", desc: "The REPEAT UNTIL loop format:", example: `REPEAT UNTIL(condition)\n{\n <block of statements>\n}` },
  forEach: { title: "FOR EACH Syntax Error", desc: "The FOR EACH loop format:", example: `FOR EACH item IN aList\n{\n <block of statements>\n}` },
  list: { title: "List Indexing Error", desc: "Lists are 1-indexed. Index must be between 1 and list length:", example: `aList ‚Üê [1, 2, 3]\nDISPLAY(aList[1])` },
  assignment: { title: "Assignment Syntax Error", desc: "Assignment uses the left arrow (‚Üê or <-):", example: `myVar ‚Üê 10` },
  display: { title: "DISPLAY Syntax Error", desc: "DISPLAY requires parentheses around the expression:", example: `DISPLAY("The result is " + x)` },
  returns: { title: "RETURN Statement Error", desc: "RETURN can only be used inside a PROCEDURE block:", example: `PROCEDURE calc(a)\n{\n RETURN(a*2)\n}` },
  block: { title: "Brace Mismatch Error", desc: "Every opening { must have a matching closing }:", example: `PROCEDURE example()\n{\n IF(condition)\n {\n <nested code>\n }\n}` },
  boolean: { title: "Boolean Expression Error", desc: "Boolean expressions evaluate to true or false:", example: `a = b\na ‚â† b\na > b a < b a ‚â• b a ‚â§ b\nNOT condition\ncond1 AND cond2\ncond1 OR cond2` },
  random: { title: "RANDOM Syntax Error", desc: "RANDOM generates a random integer from a to b inclusive:", example: `RANDOM(1, 10)` },
  mod: { title: "MOD Operator Error", desc: "MOD returns the remainder of division:", example: `17 MOD 5\nx MOD 2 = 0` },
  input: { title: "INPUT Syntax Error", desc: "INPUT accepts a value from the user:", example: `name ‚Üê INPUT()\nDISPLAY("Hello " + name)` },
  undefined: { title: "Undefined Variable Error", desc: "Make sure variables are assigned before use:", example: `x ‚Üê 10\nDISPLAY(x)` },
  length: { title: "LENGTH Syntax Error", desc: "LENGTH returns the number of elements in a list:", example: `aList ‚Üê [1, 2, 3]\nlen ‚Üê LENGTH(aList)` },
  append: { title: "APPEND Syntax Error", desc: "APPEND adds a value to the end of a list:", example: `aList ‚Üê [1, 2]\nAPPEND(aList, 3)` },
  insert: { title: "INSERT Syntax Error", desc: "INSERT adds a value at a specific index:", example: `aList ‚Üê [1, 3]\nINSERT(aList, 2, 2)` },
  remove: { title: "REMOVE Syntax Error", desc: "REMOVE removes a value at a specific index:", example: `aList ‚Üê [1, 2, 3]\nREMOVE(aList, 2)` },
  contains: { title: "CONTAINS Syntax Error", desc: "CONTAINS checks if one string is found within another:", example: `text ‚Üê "apple"\nDISPLAY(CONTAINS(text, "pp"))` }
};

function detectAndShowHelp(errorMsg, lineContent) {
  const lowerErr = errorMsg.toLowerCase();
  
  if (lowerErr.includes("undefined") && !lowerErr.includes("index") && !lowerErr.includes("length")) showSyntaxHelp("undefined");
  else if (lowerErr.includes("procedure")) showSyntaxHelp("procedure");
  else if (lowerErr.includes("if")) showSyntaxHelp("if");
  else if (lowerErr.includes("repeat") && lowerErr.includes("times")) showSyntaxHelp("repeatTimes");
  else if (lowerErr.includes("repeat") && lowerErr.includes("until")) showSyntaxHelp("repeatUntil");
  else if (lowerErr.includes("for each")) showSyntaxHelp("forEach");
  else if (lowerErr.includes("return")) showSyntaxHelp("returns");
  else if (lowerErr.includes("random")) showSyntaxHelp("random");
  else if (lowerErr.includes("mod")) showSyntaxHelp("mod");
  else if (lowerErr.includes("display")) showSyntaxHelp("display");
  else if (lowerErr.includes("input")) showSyntaxHelp("input");
  else if (lowerErr.includes("length")) showSyntaxHelp("length");
  else if (lowerErr.includes("append")) showSyntaxHelp("append");
  else if (lowerErr.includes("insert")) showSyntaxHelp("insert");
  else if (lowerErr.includes("remove")) showSyntaxHelp("remove");
  else if (lowerErr.includes("contains")) showSyntaxHelp("contains");
  else if (lowerErr.includes("list") || lowerErr.includes("index")) showSyntaxHelp("list");
  else if (lowerErr.includes("boolean") || lowerErr.includes("and") || lowerErr.includes("or") || lowerErr.includes("not")) showSyntaxHelp("boolean");
  else if (lowerErr.includes("assignment") || lowerErr.includes("‚Üê") || lowerErr.includes("<-")) showSyntaxHelp("assignment");
  else if (lowerErr.includes("{") || lowerErr.includes("}") || lowerErr.includes("block") || lowerErr.includes("followed by")) showSyntaxHelp("block");

  // Fallback for general errors
  if (!lowerErr.includes("syntax") && !lowerErr.includes("invalid") && !lowerErr.includes("unclosed")) {
    // If it's a runtime error that might be missing a var, and we didn't show a specific help, show general undefined help.
    if (lowerErr.includes("is not defined")) showSyntaxHelp("undefined");
    if (lowerErr.includes("must be followed by")) showSyntaxHelp("block");
  }
}

function showSyntaxHelp(type) {
  const h = syntaxHelp[type];
  if (h) help(h.title, h.desc, h.example);
}

function showPrompt(label) {
  promptInput.value = "";
  promptInput.placeholder = label || "Input";
  promptWrap.classList.add("show");
  promptInput.focus();
  return new Promise((res, rej) => {
    inputResolve = res;
    inputReject = rej;
  });
}

function hidePrompt() {
  promptWrap.classList.remove("show");
}

promptOk.onclick = () => {
  if (inputResolve) {
    inputResolve(promptInput.value);
    hidePrompt();
    inputResolve = null;
    inputReject = null;
  }
};

promptCancel.onclick = () => {
  if (inputReject) {
    inputReject(new Error("Input cancelled"));
    hidePrompt();
    inputResolve = null;
    inputReject = null;
  }
};

promptInput.addEventListener("keydown", e => {
  if (e.key === "Enter") promptOk.click();
  if (e.key === "Escape") promptCancel.click();
});


// ===== PARSING & EXECUTION CORE =====

function preprocess(src) {
  return src.split(/\r?\n/).map((raw, idx) => {
    const s = raw.replace(/#.*$/, "").replace(/\/\/.*$/, "").replace(/\t/g, " ").trim();
    return { idx, raw, s };
  });
}

function validateBraces(lines) {
  let depth = 0;
  let expectingOpen = false;
  let lastConstruct = "";
  let lastConstructLine = 0;
  for (const { s, idx } of lines) {
    if (s.startsWith("IF(") || s.startsWith("ELSE") || s.startsWith("REPEAT") || s.startsWith("FOR EACH") || s.startsWith("PROCEDURE")) {
      if (s !== "ELSE") {
        if (expectingOpen) throw `${lastConstruct} at line ${lastConstructLine + 1} must be followed by { before the next construct at line ${idx + 1}`;
        expectingOpen = true;
        lastConstruct = s.split(/\s+/)[0];
        lastConstructLine = idx;
      }
    }
    
    if (s === "{") {
      depth++;
      expectingOpen = false;
    } else if (s === "}") {
      depth--;
      if (depth < 0) throw `Unmatched closing } at line ${idx + 1}`;
    } else if (s && expectingOpen) {
      // Line contains non-brace code, but we expected a brace.
      throw `${lastConstruct} at line ${lastConstructLine + 1} must be followed by { at line ${idx + 1}.`;
    }
  }
  if (depth !== 0) throw `Missing closing } - ${depth} unclosed block(s). Check that all IF, ELSE, REPEAT, FOR, and PROCEDURE blocks are properly closed`;
  if (expectingOpen) throw `${lastConstruct} at line ${lastConstructLine + 1} must be followed by {`;
}

function parseProcedures(lines) {
  const procs = {};
  let i = 0;
  while (i < lines.length) {
    const t = lines[i].s;
    if (/^PROCEDURE\b/i.test(t)) {
      const m = t.match(/^PROCEDURE\s+([A-Za-z_]\w*)\s*\(([^)]*)\)/i);
      if (!m) throw `Bad PROCEDURE syntax at line ${lines[i].idx + 1}. Format: PROCEDURE procName(param1, param2)`;
      const name = m[1];
      const params = m[2].trim() ? m[2].split(",").map(s => s.trim()) : [];
      
      i++;
      if (i >= lines.length || lines[i].s !== "{") throw `PROCEDURE ${name} at line ${lines[i - 1].idx + 1} must be followed by {`;
      
      const bodyStart = i + 1;
      let depth = 1;
      i++;
      while (i < lines.length && depth > 0) {
        if (lines[i].s === "{") depth++;
        else if (lines[i].s === "}") depth--;
        i++;
      }
      if (depth !== 0) throw `Unclosed PROCEDURE ${name}`;
      const bodyEnd = i - 1;

      procs[name] = { name, params, start: bodyStart, end: bodyEnd };
    } else {
      i++;
    }
  }
  return procs;
}

let LINES = [], PROCS = null, ENV = null;

// Built-in functions available in the expression evaluator
const FUNCTIONS = {
    DISPLAY: m => log(m),
    INPUT: async () => { 
        const val = await showPrompt("Input");
        return isNaN(val) || val === "" ? val : Number(val);
    },
    APPEND: (L, v) => {
        if (!Array.isArray(L)) throw "APPEND: first argument must be a list";
        if (v === undefined) throw "APPEND requires two arguments: APPEND(aList, value)";
        L.push(v);
    },
    CONTAINS: (text, sub) => {
        if (typeof text !== "string") throw "CONTAINS: first argument must be a string";
        if (typeof sub !== "string") throw "CONTAINS: second argument must be a string";
        return text.includes(sub);
    },
    INSERT: (L, i, v) => {
        if (!Array.isArray(L)) throw "INSERT: first argument must be a list";
        if (i === undefined || v === undefined) throw "INSERT requires three arguments: INSERT(aList, i, value)";
        if (i < 1 || i > L.length + 1) throw `INSERT: invalid index ${i}. Must be between 1 and ${L.length + 1}`;
        L.splice(i - 1, 0, v);
    },
    REMOVE: (L, i) => {
        if (!Array.isArray(L)) throw "REMOVE: first argument must be a list";
        if (i === undefined) throw "REMOVE requires two arguments: REMOVE(aList, i)";
        if (i < 1 || i > L.length) throw `REMOVE: invalid index ${i}. List length is ${L.length}`;
        L.splice(i - 1, 1);
    },
    LENGTH: L => {
        if (L == null) throw "LENGTH: argument is undefined. Make sure the list exists.";
        // Added string length support
        if (typeof L === "string") return L.length; 
        if (!Array.isArray(L)) throw "LENGTH: argument must be a list or a string";
        return L.length;
    },
    // ********* CORRECTED IDX FUNCTION *********
    IDX: (L, i, j) => {
        // Convert 1-based index (i) to 0-based
        i = Math.round(i) - 1;

        // --- String Support (Indexing or Substring) ---
        if (typeof L === "string") {
            if (j !== undefined) {
                // Substring: IDX(string, start, end)
                j = Math.round(j); // 1-based end position

                if (i < 0 || i >= L.length) throw "IDX: start index out of bounds";
                
                // The 1-based end index (j) must be between 1 and L.length (inclusive)
                if (j < 1 || j > L.length) throw "IDX: end index out of bounds"; 

                if (i >= j) return "";
                
                // JavaScript's substring uses (0-based start, 0-based *exclusive* end), 
                // so passing the 1-based end position (j) is correct.
                return L.substring(i, j);
            } else {
                // String Indexing: IDX(string, index)
                if (i < 0 || i >= L.length) throw "IDX: index out of bounds";
                return L.charAt(i);
            }
        }

        // --- List Support (Indexing or Sublist) ---
        if (!Array.isArray(L)) throw "IDX: first argument must be a list or a string";

        if (j !== undefined) {
            // Sublist: IDX(list, start, end)
            j = Math.round(j); // 1-based end position

            if (i < 0 || i >= L.length) throw "IDX: start index out of bounds";
            
            // For a sublist, the 1-based end index (j) must be at most L.length.
            if (j < 1 || j > L.length) throw "IDX: end index out of bounds"; 
            
            if (i >= j) return [];
            
            // JavaScript's slice uses (0-based start, 0-based *exclusive* end),
            // so passing the 1-based end position (j) is correct.
            return L.slice(i, j);
        }

        // List Indexing: IDX(list, index)
        if (i < 0 || i >= L.length) throw "IDX: index out of bounds";
        return L[i];
    },
    // ********* END CORRECTED IDX FUNCTION *********
    RANDOM: (a, b) => {
        if (a === undefined || b === undefined) throw "RANDOM requires two arguments: RANDOM(a, b)";
        a = Math.round(a);
        b = Math.round(b);
        if (a > b) [a, b] = [b, a]; // Swap if a > b
        return Math.floor(Math.random() * (b - a + 1)) + a;
    },
    // Aliases to make it work in the JS eval environment
    MOD: (a, b) => a % b,
    NOT: b => !b,
    AND: (b1, b2) => b1 && b2,
    OR: (b1, b2) => b1 || b2,
    // Add built-in functions to the ENV for direct access in expressions
    ...Object.fromEntries(
        Object.entries({
            APPEND, CONTAINS, INSERT, REMOVE, LENGTH, IDX, RANDOM, MOD: (a, b) => a % b
        }).map(([name, fn]) => [name, fn])
    )
};

// Creates a function to evaluate an expression string
function makeEval(env, procs) {
    const scopeKeys = [...Object.keys(env), ...Object.keys(FUNCTIONS)];
    const scopeValues = [...Object.values(env), ...Object.values(FUNCTIONS)];

    // Add procedures as functions to the scope
    for (const procName in procs) {
        scopeKeys.push(procName);
        // Create an async function wrapper for the procedure call
        scopeValues.push(async function(...args) {
            const procDef = procs[procName];
            if (args.length !== procDef.params.length) {
                throw `Procedure call error: ${procName} expects ${procDef.params.length} argument(s), but received ${args.length}`;
            }
            
            const newEnv = Object.create(env);
            procDef.params.forEach((paramName, index) => {
                newEnv[paramName] = args[index];
            });
            
            // Execute the procedure body
            const returnValue = await execRange(procDef.start, procDef.end, newEnv, true);
            
            // If the procedure ended without a RETURN, return undefined
            return returnValue;
        });
    }

    return async function(e) {
        // Pre-process expression: replace pseudocode operators and list access
        e = e.replace(/‚â†/g, "!=").replace(/‚â•/g, ">=").replace(/‚â§/g, "<=");
        e = e.replace(/‚Üê|<-/g, "=");
        e = e.replace(/MOD/g, "%");
        e = e.replace(/AND/g, "&&");
        e = e.replace(/OR/g, "||");
        e = e.replace(/NOT/g, "!");
        
        // Handle list access in expressions: aList[i] -> FUNCTIONS.IDX(aList, i)
        // This is necessary because in JS eval, array access L[i] is 0-indexed.
        // The regex looks for [name][index] or [name][start, end]
        e = e.replace(/([A-Za-z_]\w*)\s*\[\s*([^\]]+)\s*\]/g, (match, listName, indices) => {
            const parts = indices.split(',').map(s => s.trim());
            if (parts.length === 1) {
                return `FUNCTIONS.IDX(${listName}, ${parts[0]})`;
            } else if (parts.length === 2) {
                return `FUNCTIONS.IDX(${listName}, ${parts[0]}, ${parts[1]})`;
            }
            throw new Error(`Invalid list/string index or substring/sublist syntax: ${match}`);
        });
        
        // Handle array literal creation: [1, 2, 3]
        e = e.replace(/\[\s*([^\]]*)\s*\]/g, (match, content) => {
            if (content.trim() === '') return '[]';
            // Replace internal assignments/operators before evaluation
            let replacedContent = content.replace(/‚Üê|<-/g, "=");
            return `[${replacedContent}]`;
        });
        
        // Handle string literals to preserve them exactly
        e = e.replace(/"/g, '`');
        
        try {
            const asyncFn = new Function(...scopeKeys, `return (async function() { return (${e}); })();`);
            return await asyncFn(...scopeValues);
        } catch (err) {
            if (err.message && err.message.includes("is not defined")) {
                const varMatch = err.message.match(/(\w+) is not defined/);
                if (varMatch) throw `Variable '${varMatch[1]}' is not defined. Make sure to assign it a value first with: ${varMatch[1]} ‚Üê value at line ${LINES[i].idx + 1}`;
            }
            throw err.message || err;
        }
    };
}


async function execRange(start, end, env, insideProc = false) {
    const evalExpr = makeEval(env, PROCS);
    let i = start;
    
    while (i < end) {
        if (halted) return null;
        
        const { s, idx } = LINES[i];
        
        if (!s || s === "{" || s === "}") {
            i++;
            continue;
        }
        
        // Skip procedure definitions when not executing a procedure
        if (!insideProc && /^PROCEDURE\b/i.test(s)) {
            const m = s.match(/^PROCEDURE\s+([A-Za-z_]\w*)/i);
            const name = m[1];
            const def = PROCS[name];
            i = def.end + 1;
            continue;
        }
        
        // RETURN
        if (/^RETURN\b/i.test(s)) {
            if (!insideProc) throw `RETURN outside procedure at line ${idx + 1}. RETURN can only be used inside a PROCEDURE.`;
            const m = s.match(/^RETURN\s*\((.*)\)/i);
            if (!m) throw `Invalid RETURN syntax at line ${idx + 1}. Use: RETURN(expression)`;
            const returnVal = m[1].trim() ? await evalExpr(m[1]) : undefined;
            return returnVal;
        }

        // DISPLAY
        if (/^DISPLAY\s*\(/i.test(s)) {
            const m = s.match(/^DISPLAY\s*\((.*)\)/i);
            if (!m) throw `Invalid DISPLAY syntax at line ${idx + 1}. Use: DISPLAY(expression)`;
            const output = await evalExpr(m[1]);
            FUNCTIONS.DISPLAY(output);
            i++;
            continue;
        }
        
        // Procedure Call (as a standalone statement)
        if (/^[A-Za-z_]\w*\s*\(/i.test(s)) {
             try {
                await evalExpr(s);
             } catch (e) {
                // Ignore return values, but propagate other errors
                if (!(e instanceof Error && e.message === "Procedure call completed.")) {
                    throw e;
                }
             }
             i++;
             continue;
        }
        
        // Assignment to variable: var ‚Üê expression
        const assignMatch = s.match(/^([A-Za-z_]\w*)\s*(?:‚Üê|<-)\s*(.*)$/);
        if (assignMatch) {
            const varName = assignMatch[1];
            const expr = assignMatch[2];
            
            // Check if it's a list assignment first: listName[i] ‚Üê value
            const listAssignMatch = varName.match(/^([A-Za-z_]\w*)\s*\[\s*([^\]]+)\s*\]/);
            if (listAssignMatch) {
                const listName = listAssignMatch[1];
                const indexExpr = listAssignMatch[2];

                if (!env[listName]) throw `Variable '${listName}' is not defined at line ${idx + 1}.`;
                const list = env[listName];
                if (!Array.isArray(list) && typeof list !== 'string') throw `Variable '${listName}' at line ${idx + 1} is not a list or string and cannot be indexed.`;

                // Evaluate index and value separately to catch errors related to the variable/list being undefined/invalid.
                const index = await evalExpr(indexExpr);
                const value = await evalExpr(expr);
                
                if (typeof list === 'string') {
                    // String assignment is not supported in the interpreter to match typical pseudocode (strings are immutable).
                    throw `String assignment error at line ${idx + 1}: Strings are immutable and cannot be assigned to an index.`;
                }

                if (index < 1 || index > list.length) throw `List index out of bounds at line ${idx + 1}. List length is ${list.length}. Remember: lists are 1-indexed.`;
                list[index - 1] = value;
                i++;
                continue;
            }
            
            // Regular variable assignment
            const value = await evalExpr(expr);
            env[varName] = value;
            i++;
            continue;
        }
        
        // IF
        if (/^IF\s*\(/i.test(s)) {
            const m = s.match(/^IF\s*\((.*)\)/i);
            if (!m) throw `Invalid IF syntax at line ${idx + 1}. Use: IF(condition)`;
            
            const cond = await evalExpr(m[1]);
            i++;
            if (i >= end || LINES[i].s !== "{") throw `IF at line ${idx + 1} must be followed by {`;
            
            const blockStart = i + 1;
            let depth = 1;
            i++;
            while (i < end && depth > 0) {
                if (LINES[i].s === "{") depth++;
                else if (LINES[i].s === "}") depth--;
                i++;
            }
            const blockEnd = i - 1;
            
            if (cond) {
                const result = await execRange(blockStart, blockEnd, env, insideProc);
                if (insideProc && result !== undefined && result !== null) return result;
                
                // Skip ELSE block if executed
                if (i < end && /^ELSE\b/i.test(LINES[i].s)) {
                    i++;
                    if (i < end && LINES[i].s === "{") {
                        depth = 1;
                        i++;
                        while (i < end && depth > 0) {
                            if (LINES[i].s === "{") depth++;
                            else if (LINES[i].s === "}") depth--;
                            i++;
                        }
                    }
                }
            } else {
                // Skip IF block
                if (i < end && /^ELSE\b/i.test(LINES[i].s)) {
                    i++;
                    if (i >= end || LINES[i].s !== "{") throw `ELSE at line ${idx + 1} must be followed by {`;
                    
                    const elseStart = i + 1;
                    depth = 1;
                    i++;
                    while (i < end && depth > 0) {
                        if (LINES[i].s === "{") depth++;
                        else if (LINES[i].s === "}") depth--;
                        i++;
                    }
                    const elseEnd = i - 1;
                    
                    const result = await execRange(elseStart, elseEnd, env, insideProc);
                    if (insideProc && result !== undefined && result !== null) return result;
                }
            }
            
            continue;
        }
        
        // REPEAT n TIMES
        if (/^REPEAT\s+.+\s+TIMES/i.test(s)) {
            const m = s.match(/^REPEAT\s+(.*?)\s+TIMES/i);
            if (!m) throw `Invalid REPEAT TIMES syntax at line ${idx + 1}. Use: REPEAT n TIMES`;
            
            const countExpr = m[1];
            const n = Math.round(await evalExpr(countExpr));
            if (typeof n !== 'number' || isNaN(n) || n < 0) throw `REPEAT count must be a non-negative number at line ${idx + 1}`;
            
            i++;
            if (i >= end || LINES[i].s !== "{") throw `REPEAT TIMES at line ${idx + 1} must be followed by {`;
            
            const blockStart = i + 1;
            let depth = 1;
            i++;
            while (i < end && depth > 0) {
                if (LINES[i].s === "{") depth++;
                else if (LINES[i].s === "}") depth--;
                i++;
            }
            const blockEnd = i - 1;
            
            for (let rep = 0; rep < n; rep++) {
                if (halted) return null;
                const result = await execRange(blockStart, blockEnd, env, insideProc);
                if (result !== undefined && result !== null && insideProc) return result;
            }
            
            continue;
        }

        // REPEAT UNTIL
        if (/^REPEAT\s+UNTIL\s*\(/i.test(s)) {
            const m = s.match(/^REPEAT\s+UNTIL\s*\((.*)\)/i);
            if (!m) throw `Invalid REPEAT UNTIL syntax at line ${idx + 1}. Use: REPEAT UNTIL(condition)`;
            
            const condExpr = m[1];
            
            i++;
            if (i >= end || LINES[i].s !== "{") throw `REPEAT UNTIL at line ${idx + 1} must be followed by {`;
            
            const blockStart = i + 1;
            let depth = 1;
            i++;
            while (i < end && depth > 0) {
                if (LINES[i].s === "{") depth++;
                else if (LINES[i].s === "}") depth--;
                i++;
            }
            const blockEnd = i - 1;
            
            while (true) {
                if (halted) return null;
                const result = await execRange(blockStart, blockEnd, env, insideProc);
                if (result !== undefined && result !== null && insideProc) return result;
                
                const cond = await evalExpr(condExpr);
                if (cond) break;
            }
            
            continue;
        }
        
        // FOR EACH
        if (/^FOR\s+EACH\s+/i.test(s)) {
            const m = s.match(/^FOR\s+EACH\s+(\w+)\s+IN\s+(.+)/i);
            if (!m) throw `Invalid FOR EACH syntax at line ${idx + 1}. Use: FOR EACH item IN aList`;
            
            const itemVar = m[1];
            const listExpr = m[2];
            
            const list = await evalExpr(listExpr);
            
            if (!Array.isArray(list) && typeof list !== 'string') throw `FOR EACH requires a list or string, but received ${typeof list} at line ${idx + 1}.`;
            
            i++;
            if (i >= end || LINES[i].s !== "{") throw `FOR EACH at line ${idx + 1} must be followed by {`;
            
            const blockStart = i + 1;
            let depth = 1;
            i++;
            while (i < end && depth > 0) {
                if (LINES[i].s === "{") depth++;
                else if (LINES[i].s === "}") depth--;
                i++;
            }
            const blockEnd = i - 1;
            
            for (const item of list) {
                if (halted) return null;
                
                // Create a temporary environment for the loop body
                const loopEnv = Object.create(env);
                loopEnv[itemVar] = item;
                
                const result = await execRange(blockStart, blockEnd, loopEnv, insideProc);
                if (result !== undefined && result !== null && insideProc) return result;
            }
            
            continue;
        }

        // Unhandled line. Could be a non-executable line (e.g., an empty line or comment line that was missed)
        // or a syntax error we didn't catch earlier.
        throw `Syntax error or unhandled command at line ${idx + 1}: ${s}`;
    }
    
    return undefined; // No return value for non-procedure blocks
}

async function run(src) {
    halted = false;
    logEl.innerHTML = "";
    setStatus("Parsing‚Ä¶", "running");
    
    try {
        LINES = preprocess(src);
        validateBraces(LINES);
        PROCS = parseProcedures(LINES);
        ENV = Object.create(null);
    } catch (e) {
        err("Parse Error: " + e);
        detectAndShowHelp(String(e), "");
        setStatus("Parse Error", "error");
        return;
    }

    setStatus("Running‚Ä¶", "running");
    try {
        await execRange(0, LINES.length, ENV, false);
        setStatus("Finished");
        sys("‚úì Program completed successfully");
    } catch (e) {
        err("Runtime Error: " + e);
        const lineMatch = String(e).match(/line\s*(\d+)/i);
        const lineNum = lineMatch ? parseInt(lineMatch[1]) - 1 : -1;
        const lineContent = lineNum >= 0 && LINES[lineNum] ? LINES[lineNum].s : "";
        detectAndShowHelp(String(e), lineContent);
        setStatus("Error", "error");
    } finally {
        hidePrompt();
    }
}


// ===== BLOCKS RENDERER - Authentic APCSP Style =====

function escapeHtml(text) {
  return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

function renderVal(expr) {
  return `<span class="block-val">${escapeHtml(expr)}</span>`;
}

function renderCond(expr) {
  return `<span class="block-cond">${escapeHtml(expr)}</span>`;
}

function renderBlock(content, isDark = false) {
  return `<span class="block-expr${isDark ? ' dark' : ''}">${content}</span>`;
}

function renderExpression(expr) {
  // Simple check for boolean/relational operators
  if (expr.match(/=|‚â†|>=|‚â§|>|<|AND|OR|NOT/i)) {
    return renderCond(expr);
  }
  return renderVal(expr);
}

function renderBlocks(ast) {
  let html = '';
  for (const block of ast) {
    switch (block.type) {
      case 'assign':
        html += `<div class="block-statement"><span class="bl">${renderVal(block.varName)} <span class="block-arrow">‚Üê</span> ${renderExpression(block.expr)}</span></div>`;
        break;
      case 'list-assign':
        html += `<div class="block-statement"><span class="bl">${renderVal(block.listName)}[${renderVal(block.index)}] <span class="block-arrow">‚Üê</span> ${renderExpression(block.value)}</span></div>`;
        break;
      case 'display':
        html += `<div class="block-statement"><span class="bl"><span class="block-keyword">DISPLAY</span>(${renderExpression(block.expr)})</span></div>`;
        break;
      case 'call':
        html += `<div class="block-statement"><span class="bl">${escapeHtml(block.expr)}</span></div>`;
        break;
      case 'return':
        html += `<div class="block-statement"><span class="bl"><span class="block-keyword">RETURN</span>(${renderExpression(block.expr)})</span></div>`;
        break;
      case 'if':
        html += `<div class="block-control"><div class="block-control-header"><span class="block-keyword">IF</span>(${renderCond(block.condition)})</div><div class="block-control-body">${renderBlocks(block.body)}</div>`;
        if (block.elseBody) {
          html += `<div class="block-else"><span class="block-keyword">ELSE</span></div><div class="block-control-body">${renderBlocks(block.elseBody)}</div>`;
        }
        html += `</div>`;
        break;
      case 'repeat-times':
        html += `<div class="block-control"><div class="block-control-header"><span class="block-keyword">REPEAT</span> ${renderVal(block.count)} <span class="block-keyword">TIMES</span></div><div class="block-control-body">${renderBlocks(block.body)}</div></div>`;
        break;
      case 'repeat-until':
        html += `<div class="block-control"><div class="block-control-header"><span class="block-keyword">REPEAT UNTIL</span>(${renderCond(block.condition)})</div><div class="block-control-body">${renderBlocks(block.body)}</div></div>`;
        break;
      case 'for-each':
        html += `<div class="block-control"><div class="block-control-header"><span class="block-keyword">FOR EACH</span> ${renderVal(block.itemVar)} <span class="block-keyword">IN</span> ${renderVal(block.listExpr)}</div><div class="block-control-body">${renderBlocks(block.body)}</div></div>`;
        break;
      case 'procedure':
        html += `<div class="block-procedure"><div class="block-procedure-header"><span class="block-keyword">PROCEDURE</span> ${escapeHtml(block.name)}(${block.params.map(p => renderVal(p)).join(', ')})</div><div class="block-procedure-body">${renderBlocks(block.body)}</div></div>`;
        break;
      case 'unknown':
        if (block.text) {
             html += `<div class="block-statement"><span class="bl" style="color:#B5514D; background-color:#ffeded;">${escapeHtml(block.text)}</span></div>`;
        }
        break;
      default:
        // Ignore { and }
        break;
    }
  }
  return html;
}

// Simple AST Parser for Blocks Renderer (only covers structure, not full semantics)
function parseBlocksAST(lines, start, end) {
    const blocks = [];
    let i = start;

    while (i < end) {
        const { s } = lines[i];

        // Procedure
        if (/^PROCEDURE\b/i.test(s)) {
            const m = s.match(/^PROCEDURE\s+([A-Za-z_]\w*)\s*\(([^)]*)\)/i);
            if (m) {
                const name = m[1];
                const params = m[2].trim() ? m[2].split(",").map(s => s.trim()) : [];
                
                i++;
                if (i < end && lines[i].s === "{") {
                    const bodyStart = i + 1;
                    let depth = 1;
                    i++;
                    while (i < end && depth > 0) {
                        if (lines[i].s === "{") depth++;
                        else if (lines[i].s === "}") depth--;
                        i++;
                    }
                    const bodyEnd = i - 1;
                    blocks.push({ 
                        type: 'procedure', 
                        name, 
                        params, 
                        body: parseBlocksAST(lines, bodyStart, bodyEnd) 
                    });
                }
            } else {
                i++;
            }
            continue;
        }

        // IF
        if (/^IF\s*\(/i.test(s)) {
            const m = s.match(/^IF\s*\((.*)\)/i);
            if (m) {
                const condition = m[1];
                i++;
                let ifBody = [];
                let elseBody = null;

                if (i < end && lines[i].s === "{") {
                    const bodyStart = i + 1;
                    let depth = 1;
                    i++;
                    while (i < end && depth > 0) {
                        if (lines[i].s === "{") depth++;
                        else if (lines[i].s === "}") depth--;
                        i++;
                    }
                    const bodyEnd = i - 1;
                    ifBody = parseBlocksAST(lines, bodyStart, bodyEnd);
                }
                
                // Check for ELSE
                if (i < end && /^ELSE\b/i.test(lines[i].s)) {
                    i++;
                    if (i < end && lines[i].s === "{") {
                        const elseStart = i + 1;
                        let depth = 1;
                        i++;
                        while (i < end && depth > 0) {
                            if (lines[i].s === "{") depth++;
                            else if (lines[i].s === "}") depth--;
                            i++;
                        }
                        const elseEnd = i - 1;
                        elseBody = parseBlocksAST(lines, elseStart, elseEnd);
                    }
                }

                blocks.push({ type: 'if', condition, body: ifBody, elseBody });
            } else {
                i++;
            }
            continue;
        }

        // REPEAT n TIMES
        if (/^REPEAT\s+.+\s+TIMES/i.test(s)) {
            const m = s.match(/^REPEAT\s+(.*?)\s+TIMES/i);
            if (m) {
                const count = m[1];
                i++;
                if (i < end && lines[i].s === "{") {
                    const bodyStart = i + 1;
                    let depth = 1;
                    i++;
                    while (i < end && depth > 0) {
                        if (lines[i].s === "{") depth++;
                        else if (lines[i].s === "}") depth--;
                        i++;
                    }
                    const bodyEnd = i - 1;
                    blocks.push({ type: 'repeat-times', count, body: parseBlocksAST(lines, bodyStart, bodyEnd) });
                }
            } else {
                i++;
            }
            continue;
        }

        // REPEAT UNTIL
        if (/^REPEAT\s+UNTIL\s*\(/i.test(s)) {
            const m = s.match(/^REPEAT\s+UNTIL\s*\((.*)\)/i);
            if (m) {
                const condition = m[1];
                i++;
                if (i < end && lines[i].s === "{") {
                    const bodyStart = i + 1;
                    let depth = 1;
                    i++;
                    while (i < end && depth > 0) {
                        if (lines[i].s === "{") depth++;
                        else if (lines[i].s === "}") depth--;
                        i++;
                    }
                    const bodyEnd = i - 1;
                    blocks.push({ type: 'repeat-until', condition, body: parseBlocksAST(lines, bodyStart, bodyEnd) });
                }
            } else {
                i++;
            }
            continue;
        }
        
        // FOR EACH
        if (/^FOR\s+EACH\s+/i.test(s)) {
            const m = s.match(/^FOR\s+EACH\s+(\w+)\s+IN\s+(.+)/i);
            if (m) {
                const itemVar = m[1];
                const listExpr = m[2];
                i++;
                if (i < end && lines[i].s === "{") {
                    const bodyStart = i + 1;
                    let depth = 1;
                    i++;
                    while (i < end && depth > 0) {
                        if (lines[i].s === "{") depth++;
                        else if (lines[i].s === "}") depth--;
                        i++;
                    }
                    const bodyEnd = i - 1;
                    blocks.push({ type: 'for-each', itemVar, listExpr, body: parseBlocksAST(lines, bodyStart, bodyEnd) });
                }
            } else {
                i++;
            }
            continue;
        }

        // DISPLAY
        if (/^DISPLAY\s*\(/i.test(s)) {
            const m = s.match(/^DISPLAY\s*\((.*)\)/i);
            if (m) {
                blocks.push({ type: 'display', expr: m[1] });
            }
            i++;
            continue;
        }

        // RETURN
        if (/^RETURN\s*\(/i.test(s)) {
            const m = s.match(/^RETURN\s*\((.*)\)/i);
            if (m) {
                blocks.push({ type: 'return', expr: m[1] });
            }
            i++;
            continue;
        }

        // Assignment with list index: list[index] ‚Üê value
        if (/^[A-Za-z_]\w*\s*\[.*\]\s*(‚Üê|<-)/.test(s)) {
            const m = s.match(/^([A-Za-z_]\w*)\s*\[\s*(.*?)\s*\]\s*(?:‚Üê|<-)\s*(.*)$/);
            if (m) {
                blocks.push({ type: 'list-assign', listName: m[1], index: m[2], value: m[3] });
            }
            i++;
            continue;
        }

        // Assignment: var ‚Üê expression
        if (/^[A-Za-z_]\w*\s*(‚Üê|<-)/.test(s)) {
            const m = s.match(/^([A-Za-z_]\w*)\s*(?:‚Üê|<-)\s*(.*)$/);
            if (m) {
                blocks.push({ type: 'assign', varName: m[1], expr: m[2] });
            }
            i++;
            continue;
        }

        // Procedure call or other function
        if (/^[A-Za-z_]\w*\s*\(/i.test(s)) {
            blocks.push({ type: 'call', expr: s });
            i++;
            continue;
        }

        // Unknown - just show as text
        if (s) {
            blocks.push({ type: 'unknown', text: s });
        }
        i++;
    }

    return blocks;
}

function renderBlocksModal() {
  blocksBody.innerHTML = '';
  try {
    const lines = preprocess(editor.value);
    const ast = parseBlocksAST(lines, 0, lines.length);
    const html = renderBlocks(ast);
    blocksBody.innerHTML = `<div class="block-container">${html || '<p style="color:#888; text-align:center; padding: 40px;">No code to display</p>'}</div>`;
  } catch (e) {
    blocksBody.innerHTML = `<div class="blocks-error">Error parsing code: ${escapeHtml(String(e))}</div>`;
  }
}

// ===== EVENT LISTENERS =====

$("#runBtn").onclick = () => run(editor.value);
$("#stopBtn").onclick = () => {
  halted = true;
  if (inputReject) {
    inputReject(new Error("Stopped"));
    hidePrompt();
  }
  setStatus("Stopped", "error");
};

$("#copyBtn").onclick = async () => {
  try {
    await navigator.clipboard.writeText(editor.value);
    showToast("Code copied to clipboard!");
  } catch (e) {
    err("Failed to copy code");
  }
};

$("#blocksBtn").onclick = () => {
  renderBlocksModal();
  blocksModal.classList.add("show");
};
$("#closeBlocks").onclick = () => blocksModal.classList.remove("show");
blocksModal.onclick = e => {
  if (e.target === blocksModal) blocksModal.classList.remove("show");
};

document.addEventListener("keydown", e => {
  if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
    e.preventDefault();
    $("#runBtn").click();
  }
  if (e.key === "Escape") {
    blocksModal.classList.remove("show");
    helpModal.classList.remove("show");
  }
});

$("#helpBtn").onclick = () => helpModal.classList.add("show");
$("#closeHelp").onclick = () => helpModal.classList.remove("show");
helpModal.onclick = e => {
  if (e.target === helpModal) helpModal.classList.remove("show");
};

// Samples setup
const samples = {
  variables: {
    label: "Variables",
    icon: "V",
    items: {
      "Variables & Types": `num ‚Üê 42\ntext ‚Üê "Hello"\nflag ‚Üê true\n\nDISPLAY(num)\nDISPLAY(text)\nDISPLAY(flag)`,
      "Arithmetic": `x ‚Üê 10\ny ‚Üê 3\n\ndiv ‚Üê x / y\nmod ‚Üê x MOD y\n\nDISPLAY(div)\nDISPLAY(mod)\nDISPLAY((x * 2) - 5)`,
      "Random Numbers": `roll ‚Üê RANDOM(1, 6)\nDISPLAY("Dice roll: " + roll)\n\ncoin ‚Üê RANDOM(1, 2)\nIF(coin = 1)\n{\n DISPLAY("Heads!")\n}\nELSE\n{\n DISPLAY("Tails!")\n}`
    }
  },
  conditionals: {
    label: "Conditionals",
    icon: "I",
    items: {
      "IF Statement": `age ‚Üê 18\nIF(age ‚â• 18)\n{\n DISPLAY("You can vote!")\n}`,
      "IF-ELSE": `score ‚Üê 75\nIF(score ‚â• 60)\n{\n DISPLAY("You passed!")\n}\nELSE\n{\n DISPLAY("Try again.")\n}`,
      "Nested IF": `grade ‚Üê 85\n\nIF(grade ‚â• 90)\n{\n DISPLAY("A")\n}\nELSE\n{\n IF(grade ‚â• 80)\n {\n DISPLAY("B")\n }\n ELSE\n {\n IF(grade ‚â• 70)\n {\n DISPLAY("C")\n }\n ELSE\n {\n DISPLAY("Below C")\n }\n }\n}`,
      "Boolean Conditions": `x ‚Üê 15\nIF(x > 10 AND x < 20)\n{\n DISPLAY("x is between 10 and 20")\n}`,
      "NOT Operator": `isRaining ‚Üê false\nIF(NOT isRaining)\n{\n DISPLAY("Go outside!")\n}\nELSE\n{\n DISPLAY("Take an umbrella")\n}`
    }
  },
  loops: {
    label: "Loops",
    icon: "R",
    items: {
      "REPEAT n TIMES": `REPEAT 5 TIMES\n{\n DISPLAY("Hello!")\n}`,
      "REPEAT with Counter": `count ‚Üê 1\nREPEAT 5 TIMES\n{\n DISPLAY("Count: " + count)\n count ‚Üê count + 1\n}`,
      "REPEAT UNTIL": `num ‚Üê 1\nREPEAT UNTIL(num > 5)\n{\n DISPLAY(num)\n num ‚Üê num + 1\n}`,
      "FOR EACH with List": `colors ‚Üê ["red", "green", "blue"]\nFOR EACH color IN colors\n{\n DISPLAY(color)\n}`,
      "FOR EACH with String": `word ‚Üê "CITRIN"\nFOR EACH letter IN word\n{\n DISPLAY(letter)\n}`
    }
  },
  procedures: {
    label: "Procedures",
    icon: "P",
    items: {
      "Simple Procedure (No Return)": `PROCEDURE greet(name)\n{\n DISPLAY("Hello, " + name + "!")\n}\n\ngreet("World")\ngreet("User")`,
      "Procedure with RETURN": `PROCEDURE calculateArea(width, height)\n{\n RETURN(width * height)\n}\n\narea ‚Üê calculateArea(5, 10)\nDISPLAY("Area is: " + area)`,
      "Scope Example": `x ‚Üê 100\n\nPROCEDURE showX()\n{\n x ‚Üê 50 // This changes the global x\n DISPLAY("Inside: " + x)\n}\n\nDISPLAY("Before: " + x)\nshowX()\nDISPLAY("After: " + x)`
    }
  },
  lists: {
    label: "Lists & Strings",
    icon: "L",
    items: {
      "List Basics": `myList ‚Üê [10, 20, 30]\nDISPLAY("Length: " + LENGTH(myList))\nDISPLAY("Third element: " + myList[3])`,
      "List Modification": `nums ‚Üê [1, 2, 4]\nINSERT(nums, 3, 3) // Insert 3 at index 3\nAPPEND(nums, 5)\nREMOVE(nums, 1) // Remove 1st element\nDISPLAY(nums)`,
      "Substring/Sublist (FIXED)": `text ‚Üê "apple pie"\nsubtext ‚Üê IDX(text, 7, 9) // 1-indexed from 7 to 9\nDISPLAY("Subtext: " + subtext)\n\nlist ‚Üê [10, 20, 30, 40]\nsublist ‚Üê IDX(list, 2, 3) // 1-indexed from 2 to 3\nDISPLAY("Sublist: " + sublist)`,
      "String CONTAINS": `word ‚Üê "programming"\ncheck1 ‚Üê CONTAINS(word, "gram")\ncheck2 ‚Üê CONTAINS(word, "xyz")\nDISPLAY(check1)\nDISPLAY(check2)`
    }
  },
  programs: {
    label: "Program Samples",
    icon: "S",
    items: {
      "1. Variables & Booleans": `name ‚Üê "Student"\nscore1 ‚Üê 85\nscore2 ‚Üê 92\n\nDISPLAY("Welcome, " + name + "!")\nDISPLAY("Score 1: " + score1)\nDISPLAY("Score 2: " + score2)\n\naverage ‚Üê (score1 + score2) / 2\nDISPLAY("Average: " + average)\n\nDISPLAY("Score1 > Score2: " + (score1 > score2))\nDISPLAY("Both above 80: " + (score1 > 80 AND score2 > 80))`,
      "2. Variables & IF": `DISPLAY("Enter your score:")\nscore ‚Üê INPUT()\n\nIF(score ‚â• 90)\n{\n grade ‚Üê "A"\n}\nELSE\n{\n IF(score ‚â• 80)\n {\n grade ‚Üê "B"\n }\n ELSE\n {\n IF(score ‚â• 70)\n {\n grade ‚Üê "C"\n }\n ELSE\n {\n grade ‚Üê "F"\n }\n }\n}\n\nDISPLAY("Grade: " + grade)`,
      "3. Variables, List & IF": `scores ‚Üê [78, 92, 65, 88, 95, 71]\nDISPLAY("Scores: " + scores)\n\nmax ‚Üê scores[1]\nFOR EACH score IN scores\n{\n IF(score > max)\n {\n max ‚Üê score\n }\n}\n\nDISPLAY("Highest Score: " + max)`,
      "4. Bubble Sort (Procedure)": `list ‚Üê [5, 1, 4, 2, 8]\nDISPLAY("Original: " + list)\n\nPROCEDURE bubbleSort(aList)\n{\n n ‚Üê LENGTH(aList)\n REPEAT n TIMES\n {\n  REPEAT n - 1 TIMES\n  {\n   i ‚Üê LENGTH(aList) - LENGTH(aList) + 1 // Ensure i starts at 1\n   current ‚Üê aList[i]\n   next ‚Üê aList[i + 1]\n\n   IF(current > next)\n   {\n    // Swap\n    aList[i] ‚Üê next\n    aList[i + 1] ‚Üê current\n   }\n   i ‚Üê i + 1\n  }\n }\n}\n\nbubbleSort(list)\nDISPLAY("Sorted: " + list)`
    }
  }
};

const samplesMenu = $("#samplesMenu");
const categoryIcons = {
  variables: "V",
  conditionals: "I",
  loops: "R",
  procedures: "P",
  lists: "L",
  programs: "S"
};

for (const [catKey, category] of Object.entries(samples)) {
  const catEl = document.createElement("div");
  catEl.className = "dropdown-category";
  catEl.textContent = category.label;
  samplesMenu.appendChild(catEl);

  for (const [name, code] of Object.entries(category.items)) {
    const item = document.createElement("div");
    item.className = `dropdown-item cat-${catKey}`;
    item.innerHTML = `<span class="icon">${categoryIcons[catKey]}</span>${name}`;
    item.onclick = () => {
      editor.value = code;
      updateLineNumbers();
      samplesMenu.classList.remove("show");
    };
    samplesMenu.appendChild(item);
  }
}

const samplesBtn = $("#samplesBtn");
samplesBtn.onclick = (e) => {
  e.stopPropagation();
  samplesMenu.classList.toggle("show");
};

document.addEventListener("click", () => samplesMenu.classList.remove("show"));
samplesMenu.onclick = (e) => e.stopPropagation();

editor.value = `DISPLAY("Welcome to AP CSP Console!")\nDISPLAY("Select an example from the menu above.")`;
updateLineNumbers();

const resizer = $("#resizer");
const mainEl = $("main");
let isResizing = false;

// Resizer logic
resizer.addEventListener("mousedown", (e) => {
  isResizing = true;
  document.body.style.cursor = "col-resize";
  e.preventDefault();
});

document.addEventListener("mousemove", (e) => {
  if (!isResizing) return;
  const mainRect = mainEl.getBoundingClientRect();
  const offsetX = e.clientX - mainRect.left;
  const percentage = (offsetX / mainRect.width) * 100;
  if (percentage > 20 && percentage < 80) {
    mainEl.style.gridTemplateColumns = `${percentage}fr ${100 - percentage}fr`;
    resizer.style.left = `calc(${percentage}% - 6px)`;
  }
});

document.addEventListener("mouseup", () => {
  if (isResizing) {
    isResizing = false;
    document.body.style.cursor = "default";
    // Force line numbers update after resize (debounce could be added)
    updateLineNumbers(); 
  }
});

editor.addEventListener("input", updateLineNumbers);
editor.addEventListener("scroll", () => {
  lineNumbers.scrollTop = editor.scrollTop;
});

// Initial setup
updateLineNumbers();

// Theme Toggle
const themeBtn = $("#themeBtn");
const currentTheme = localStorage.getItem('theme') || 'dark-mode';
document.body.classList.add(currentTheme);

themeBtn.onclick = () => {
  if (document.body.classList.contains('light-mode')) {
    document.body.classList.remove('light-mode');
    document.body.classList.add('dark-mode');
    localStorage.setItem('theme', 'dark-mode');
  } else {
    document.body.classList.remove('dark-mode');
    document.body.classList.add('light-mode');
    localStorage.setItem('theme', 'light-mode');
  }
  
  // Update icon based on theme
  const isLight = document.body.classList.contains('light-mode');
  themeBtn.innerHTML = isLight
    ? '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>'
    : '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>';
};
themeBtn.click(); // Initial call to set the correct icon
</script>

</body>
</html>
