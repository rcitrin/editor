<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Citrin's APCSP Console ‚Äî (Version 1.0)</title>
<style>
:root { --bg:#000; --panel:#0b0f14; --accent:#60a5fa; --muted:#9aa4b2; --border:#1f2937; }
*{box-sizing:border-box}
body{margin:0;background:#000;color:#e5e7eb;font:16px/1.45 system-ui,-apple-system,Segoe UI,Inter,Roboto,sans-serif}
header{padding:18px 20px;border-bottom:1px solid var(--border);background:#000;position:sticky;top:0;z-index:1}
h1{margin:0 0 6px;font-size:20px}
.sub{color:var(--muted);font-size:13px}
main{display:grid;grid-template-columns:1.1fr .9fr;gap:12px;padding:12px}
.card{background:#0a0a0a;border:1px solid var(--border);border-radius:12px;overflow:hidden;box-shadow:0 10px 25px rgba(0,0,0,.4);display:flex;flex-direction:column;min-height:0}
.card h2{font-size:14px;margin:0;padding:10px 12px;color:#cbd5e1;border-bottom:1px solid var(--border);background:#0b0b0b}
.toolbar{display:flex;gap:8px;padding:10px;border-bottom:1px solid var(--border);align-items:center;flex-wrap:wrap}
button,select{background:#141a26;color:#e5e7eb;border:1px solid var(--border);padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600}
button.primary{background:var(--accent);color:#05122a;border-color:#3b82f6}
button.danger{background:#1a1620;color:#fecaca;border-color:#7f1d1d}
textarea{flex:1;width:100%;height:520px;resize:none;background:#0c1320;color:#e5e7eb;border:0;outline:none;padding:12px 14px;font:14px/1.45 ui-monospace,Menlo,Consolas,monospace;caret-color:var(--accent);min-height:0}
.console{flex:1;overflow:auto;padding:12px;font:14px/1.5 ui-monospace,Menlo,Consolas,monospace;background:#05080f;white-space:pre-wrap}
.line{white-space:pre-wrap}
.log{color:#d1fae5}.err{color:#fecaca}.sys{color:#93c5fd}
.prompt-wrap{display:none;gap:8px;padding:10px;border-top:1px solid var(--border);background:#0d1420;align-items:center}
.prompt-wrap input{flex:1;background:#0b1220;color:#e5e7eb;border:1px solid var(--border);border-radius:10px;padding:10px 12px}
.prompt-wrap.show{display:flex}
.status{padding:8px 12px;font-size:12px;color:#9aa4b2;border-top:1px solid var(--border);background:#0e1522}
footer{color:#9aa4b2;text-align:center;font-size:12px;padding:10px;border-top:1px solid var(--border);background:#000}
</style>
</head>
<body>
<header>
  <h1>Citrin's APCSP Console <span style="opacity:.7">(Version 1.0)</span></h1>
  <div class="sub">SET, DISPLAY, INPUT, IF/ELSE/END IF, REPEAT n TIMES/END REPEAT, REPEAT UNTIL/END REPEAT, PROCEDURE/RETURN/END PROCEDURE. Lists 1-based (L[1]); APPEND/INSERT/REMOVE; LENGTH OF. <b>CALL required as a statement</b>. Procedure calls allowed inside expressions.</div>
</header>

<main>
  <section class="card">
    <h2>Program</h2>
    <div class="toolbar">
      <button class="primary" id="runBtn">‚ñ∂ Run</button>
      <button id="stopBtn" class="danger">‚ñ† Stop</button>
      <select id="samples"></select>
      <span style="margin-left:auto" class="sub">Ctrl/‚åò + Enter</span>
    </div>
    <textarea id="editor"></textarea>
  </section>

  <section class="card">
    <h2>Console</h2>
    <div class="console" id="console"></div>
    <div class="prompt-wrap" id="promptWrap">
      <input id="promptInput" placeholder="Enter input‚Ä¶" />
      <button id="promptOk">OK</button>
      <button id="promptCancel">Cancel</button>
    </div>
    <div class="status" id="status">Idle</div>
  </section>
</main>

<footer>MIT ¬∑ Single-file ¬∑ Black BG for quick version check üñ§</footer>

<script>
window.addEventListener("DOMContentLoaded", () => {
  const $ = s => document.querySelector(s);

  // UI
  const logEl = $("#console"), statusEl = $("#status"), editor = $("#editor");
  const promptWrap = $("#promptWrap"), promptInput = $("#promptInput");
  const promptOk = $("#promptOk"), promptCancel = $("#promptCancel");
  let halted = false, inputResolve=null, inputReject=null;

  const out=(m,c="log")=>{const d=document.createElement("div");d.className="line "+c;d.textContent=String(m);logEl.appendChild(d);logEl.scrollTop=logEl.scrollHeight;}
  const log=m=>out(m,"log"), err=m=>out(m,"err"), sys=m=>out(m,"sys");
  const setStatus = s => statusEl.textContent = s;

  function showPrompt(label){ promptInput.value=""; promptInput.placeholder=label||"Input"; promptWrap.classList.add("show"); promptInput.focus(); return new Promise((res,rej)=>{inputResolve=res;inputReject=rej;}); }
  function hidePrompt(){ promptWrap.classList.remove("show"); }
  promptOk.onclick=()=>{ if(inputResolve){ inputResolve(promptInput.value); hidePrompt(); } };
  promptCancel.onclick=()=>{ if(inputReject){ inputReject("cancel"); hidePrompt(); } };
  promptInput.addEventListener("keydown", e=>{ if(e.key==="Enter")promptOk.click(); if(e.key==="Escape")promptCancel.click(); });

  // ---------- Preprocess ----------
  function preprocess(src){
    return src.split(/\r?\n/).map((raw,idx)=>{
      const s = raw
        .replace(/#.*$/,"").replace(/\/\/.*$/,"")
        .replace(/[{}]/g,"")               // tolerate braces; ignore them
        .replace(/\t/g,"    ").trim();
      return { idx, raw, s };
    });
  }

  // ---------- Block map ----------
  function buildBlocks(lines){
    const blocks = { if:{}, repStartToEnd:{}, repEndToStart:{} };
    const stack = [];
    for (let i=0;i<lines.length;i++){
      const t = lines[i].s;
      if(!t) continue;
      if(/^IF\b/i.test(t)) { stack.push({type:"IF", i}); }
      else if(/^ELSE\b/i.test(t)) {
        const top = stack.at(-1);
        if(!top || top.type!=="IF") throw `ELSE without IF at line ${i+1}`;
        blocks.if[top.i] = blocks.if[top.i] || {};
        blocks.if[top.i].else = i;
      }
      else if(/^END\s*IF\b/i.test(t)) {
        const top = stack.pop();
        if(!top || top.type!=="IF") throw `END IF without IF at line ${i+1}`;
        blocks.if[top.i] = blocks.if[top.i] || {};
        blocks.if[top.i].end = i;
      }
      else if(/^REPEAT\s+\d+\s+TIMES\b/i.test(t)) { stack.push({type:"RT", i}); }
      else if(/^REPEAT\s+UNTIL\b/i.test(t)) { stack.push({type:"RU", i}); }
      else if(/^END\s*REPEAT\b/i.test(t)) {
        const top = stack.pop();
        if(!top || (top.type!=="RT" && top.type!=="RU")) throw `END REPEAT without REPEAT at line ${i+1}`;
        blocks.repStartToEnd[top.i] = i;
        blocks.repEndToStart[i] = top.i;
      }
    }
    if(stack.length) throw `Unclosed block at line ${stack[0].i+1}`;
    return blocks;
  }

  // ---------- Procedures table ----------
  function parseProcedures(lines){
    const procs = {};
    let open = null;
    for (let i=0;i<lines.length;i++){
      const t = lines[i].s;
      if(!t) continue;

      if(/^PROCEDURE\b/i.test(t)){
        // allow optional trailing spaces; params may be empty
        const m = t.match(/^PROCEDURE\s+([A-Za-z_]\w*)\s*\(([^)]*)\)\s*$/i);
        if(!m) throw `Bad PROCEDURE syntax at line ${i+1}`;
        if(open) throw `Nested PROCEDURE not allowed (line ${i+1})`;
        open = { name: m[1], params: m[2].trim()? m[2].split(",").map(s=>s.trim()) : [], start: i+1, end: null };
      }
      else if(/^END\s+PROCEDURE\b/i.test(t)){
        if(!open) throw `END PROCEDURE without PROCEDURE at line ${i+1}`;
        open.end = i;
        procs[open.name] = open;
        open = null;
      }
    }
    if(open) throw `Unclosed PROCEDURE '${open.name}' starting at line ${open.start}`;
    return procs;
  }

  // ---------- Expression evaluator ----------
  function makeEval(env, procs){
    const safe=/^[\w\s+\-*/%().,<>!=‚Äú‚Äù"'\[\]‚â§‚â•‚â†?:]+$/u;
    function rewrite(expr){
      return expr
        .replace(/[‚Äú‚Äù]/g,'"')
        .replace(/‚â§/g,"<=").replace(/‚â•/g,">=").replace(/‚â†/g,"!=")
        .replace(/\bAND\b/gi,"&&").replace(/\bOR\b/gi,"||").replace(/\bNOT\b/gi,"!")
        .replace(/\bLENGTH\s+OF\s+([A-Za-z_]\w*)/gi, "LENGTH($1)")
        .replace(/([A-Za-z_]\w*)\s*\[\s*([^\]]+)\s*\]/g, "IDX($1,($2))");
    }

    async function callProc(name, args, callerEnv){
      const def = procs[name];
      if(!def) throw `Unknown procedure '${name}'`;
      const local = Object.create(callerEnv);
      for(let i=0;i<def.params.length;i++) local[def.params[i]] = args[i];
      const result = await execRange(def.start, def.end, local, true);
      return result.__ret ?? null;
    }

    return async function evalExpr(expr){
      const e = rewrite(expr);
      if(!safe.test(e)) throw "Expression contains unsupported characters";

      const scope = {
        ...env, Math,
        INPUT: async prompt => showPrompt(prompt||"Input"),
        APPEND: (L,v)=>L.push(v),
        INSERT: (L,i,v)=>L.splice(i-1,0,v),
        REMOVE: (L,i)=>L.splice(i-1,1),
        LENGTH: L=>L.length,
        IDX: (L,i)=>L[(i|0)-1]
      };
      for(const name in procs){
        scope[name] = async (...args)=>await callProc(name,args,env);
      }
      const keys = Object.keys(scope), vals = Object.values(scope);
      const fn = new Function(...keys, `return ( ${e} );`);
      return await fn(...vals);
    };
  }

  // ---------- Globals for current program ----------
  let LINES=[], BLOCKS=null, PROCS=null, ENV=null, EVAL=null;

  // ---------- Executor ----------
  async function execRange(start, end, env, insideProc=false){
    const evalExpr = (env===ENV ? EVAL : makeEval(env, PROCS));
    let i = start;
    env.__times = env.__times || {};

    while(i < end){
      if(halted) return {__halt:true};
      const {s, idx} = LINES[i];
      i++;
      if(!s) continue;

      // Skip procedure bodies at top level
      if(!insideProc && /^PROCEDURE\b/i.test(s)){
        const m = s.match(/^PROCEDURE\s+([A-Za-z_]\w*)/i);
        const name = m && m[1];
        const def = name ? PROCS[name] : null;
        if(!def) throw `Procedure header not recognized at line ${idx+1}`;
        i = def.end + 1;
        continue;
      }
      if(/^END\s+PROCEDURE\b/i.test(s)){
        if(insideProc) return {__ret:null};
        continue;
      }

      // RETURN (only valid inside a procedure)
      if(/^RETURN\b/i.test(s)){
        if(!insideProc) throw `RETURN outside of PROCEDURE at line ${idx+1}`;
        const expr = s.replace(/^RETURN\b/i,"").trim();
        const val = expr ? await evalExpr(expr) : null;
        return {__ret: val};
      }

      // DISPLAY(expr)
      if(/^DISPLAY\s*\(/i.test(s)){
        const m = s.match(/^DISPLAY\s*\((.*)\)\s*$/i);
        if(!m) throw `DISPLAY syntax at line ${idx+1}`;
        log(await evalExpr(m[1]));
        continue;
      }

      // SET x ‚Üê expr  or  x ‚Üê expr
      if(/^(SET\s+)?[A-Za-z_]\w*\s*(‚Üê|<-)/.test(s)){
        const m = s.match(/^(?:SET\s+)?([A-Za-z_]\w*)\s*(?:‚Üê|<-)\s*(.*)$/i);
        env[m[1]] = await evalExpr(m[2]);
        continue;
      }

      // IF / ELSE / END IF
      if(/^IF\b/i.test(s)){
        const cond = s.replace(/^IF\b/i,"").replace(/\bTHEN\b/i,"").trim();
        const ok = await evalExpr(cond);
        const meta = BLOCKS.if[idx];
        if(!meta) throw `IF without END IF at line ${idx+1}`;
        if(!ok){ i = (meta.else!=null ? meta.else+1 : meta.end+1); }
        continue;
      }
      if(/^ELSE\b/i.test(s)){
        const startIf = [...Object.keys(BLOCKS.if).map(k=>+k)].reverse().find(k=>k<idx);
        i = BLOCKS.if[startIf].end + 1;
        continue;
      }
      if(/^END\s*IF\b/i.test(s)){ continue; }

      // REPEAT n TIMES (handled at END REPEAT)
      if(/^REPEAT\s+\d+\s+TIMES\b/i.test(s)){ continue; }

      // REPEAT UNTIL cond (store cond for end)
      if(/^REPEAT\s+UNTIL\b/i.test(s)){
        const cond = s.replace(/^REPEAT\s+UNTIL\b/i,"").trim();
        env[`__until_${idx}`] = cond;
        continue;
      }

      // END REPEAT
      if(/^END\s*REPEAT\b/i.test(s)){
        const startIdx = BLOCKS.repEndToStart[idx];
        const startLine = LINES[startIdx].s;

        if(/^REPEAT\s+\d+\s+TIMES\b/i.test(startLine)){
          const n = parseInt(startLine.match(/^REPEAT\s+(\d+)\s+TIMES\b/i)[1],10);
          env.__times[startIdx] = (env.__times[startIdx] || 0) + 1;
          if(env.__times[startIdx] < n) i = startIdx + 1;
          else delete env.__times[startIdx];
        } else { // REPEAT UNTIL (post-check)
          const cond = env[`__until_${startIdx}`];
          const ok = await evalExpr(cond);
          if(!ok) i = startIdx + 1;
        }
        continue;
      }

      // Statement calls must use CALL (strict)
      if(/^CALL\s+[A-Za-z_]\w*\s*\(/i.test(s)){
        await evalExpr(s.replace(/^CALL\s+/i,""));
        continue;
      }

      // INPUT as a statement (side effect only)
      if(/^INPUT\s*\(/i.test(s)){ await evalExpr(s); continue; }

      // Bare proc call as statement is disallowed in strict mode
      if(/^[A-Za-z_]\w*\s*\(/.test(s)){
        throw `Use CALL name(args) for procedure statements (line ${idx+1}).`;
      }

      throw `Unknown statement at line ${idx+1}: ${s}`;
    }
    return {__ret:null};
  }

  // ---------- Run ----------
  async function run(src){
    halted=false; logEl.innerHTML=""; setStatus("Parsing‚Ä¶");
    try{
      LINES = preprocess(src);
      BLOCKS = buildBlocks(LINES);
      PROCS  = parseProcedures(LINES);
      ENV = Object.create(null);
      EVAL = makeEval(ENV, PROCS);
    }catch(e){ err(e); setStatus("Crashed"); return; }

    setStatus("Running‚Ä¶");
    try{
      await execRange(0, LINES.length, ENV, false);
      setStatus("Finished");
    }catch(e){ err(e); setStatus("Crashed"); }
  }

  // ---------- UI ----------
  $("#runBtn").onclick = ()=> run(editor.value);
  $("#stopBtn").onclick = ()=> { halted=true; setStatus("Stopping‚Ä¶"); };
  document.addEventListener("keydown", e=>{
    if((e.ctrlKey||e.metaKey) && e.key==="Enter"){ e.preventDefault(); $("#runBtn").click(); }
  });

  const samples = {
"Strict: Procedure + CALL":
`PROCEDURE hello()
  DISPLAY("hello")
END PROCEDURE

CALL hello()`,

"Strict: RETURN in expression":
`PROCEDURE pay(hours, rate)
  RETURN hours * rate
END PROCEDURE

SET paycheck ‚Üê pay(12, 18.5)
DISPLAY("Pay = $" + paycheck)`,

"Strict: Loops":
`REPEAT 3 TIMES
  DISPLAY("tick")
END REPEAT

SET i ‚Üê 0
REPEAT UNTIL i ‚â• 3
  DISPLAY(i)
  SET i ‚Üê i + 1
END REPEAT`
  };
  const sel = $("#samples");
  sel.innerHTML = '<option value="">Load sample‚Ä¶</option>' + Object.keys(samples).map(k=>`<option>${k}</option>`).join('');
  sel.onchange = e=>{ const k=e.target.value; if(samples[k]) editor.value=samples[k]; e.target.value=""; };

  // Start blank
  editor.value = "";

  setStatus("Ready"); sys("Strict mode loaded. CALL required for statements; braces ignored.");
});
</script>
</body>
</html>
